<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CesiumJS GeoJSON Example</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.116/Build/Cesium/Cesium.js"></script>
    <style>
        @import url(https://cesium.com/downloads/cesiumjs/releases/1.116/Build/Cesium/Widgets/widgets.css);

        .cesium-selection-wrapper {
            display: none !important;
        }

        #cesiumContainer {
            width: 100%;
            height: calc(85vh - 55px);
            float: left;
            position: relative;
        }

        #cesiumTexture {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #distanceControl {
            position: absolute;
            bottom: 20px;
            left: 15px;
            z-index: 1;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }

        #distanceDisplay {
            margin-bottom: 5px;
        }

        #clearButton {
            margin-right: 10px;
        }

        #fileSelection {
            position: absolute;
            bottom: 100px;
            left: 10px;
            z-index: 1;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 50px;
        }

        #logoContainer {
            position: absolute;
            bottom: 110px;
            right: 10px;
            z-index: 1;
        }

        #logoContainer img {
            width: 200px;
        }

        #legendContainer {
            width: auto;
            float: left;
            padding: 20px;
            position: absolute;
            bottom: 110px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
        }

        #auxLegendContainer {
            width: auto;
            float: left;
            padding: 20px;
            position: absolute;
            bottom: 60px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
        }

        .legendItem {
            margin-bottom: 10px;
            display: inline-block;
            margin-right: 20px;
        }

        .legendColor {
            width: 20px;
            height: 20px;
            display: inline-block;
            margin-right: 5px;
        }

        .checkboxRow {
            display: flex;
            flex-wrap: wrap;
        }

        .checkboxRow label {
            margin-right: 10px;
        }

        #toggleButton,
        #controlContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            padding: 10px;
            background-color: #ffffff;
            border: 1px solid #cccccc;
            border-radius: 5px;
            cursor: pointer;
        }

        #controlContainer {
            background-color: rgba(255, 255, 255, 0.4);
            z-index: 1000;
        }

        #toggleGlobeContainer,
        #toggleSubductionInterface,
        #eqcontrols,
        #toggleTerrainOcclusion {
            margin-bottom: 10px;
        }

        #eqcontrols {
            background-color: transparent;
        }

        .sliderContainer {
            margin-bottom: 10px;
        }

        .sliderLabel {
            margin-right: 10px;
        }

        .button {
            background-color: #004F59;
            color: lightgray;
            width: 100%;
            border-radius: 15px;
            /* Adjust the value to make the corners more or less rounded */
        }
    </style>
</head>

<body>
    <!--script type="module" src="./depth-slice-3d.html"></script-->
    <div id="cesiumContainer"></div>
    <div id="controlContainer">
        <center><b>CFM 3D Viewer</b></center>
        <hr />
        <div id="toggleGlobeContainer">
            <label>
                <input type="checkbox" id="toggleGlobeCheckbox">Imagery layer
            </label>
        </div>
        <div id="toggleSubductionInterface">
            <label>
                <input type="checkbox" id="toggleSubductionCheckbox" checked> Cascadia Subduction Interface
            </label>
        </div>
        <div id="eqcontrols">
            <label><input type="checkbox" id="showEarthquakesCheckbox" checked> Earthquakes</label>
            <br>
            <label>Circle Size: <input type="range" id="circleSizeSlider" min="0" max="0.2" step="0.01"
                    value="0.04"></label>
        </div>
        <div id="toggleTerrainOcclusion">
            <label>
                <input type="checkbox" id="toggleTerrainOcclusionCheckbox" checked> Terrain Occlusion
            </label>
        </div>
        <!-- Slider controls for model boundaries -->
        <div>
            <hr style="border-top: 1px solid #0000FF" />
        </div>
        <form id="iframe-form">
            <div>
                <label for="data-file">CVM:</label>
                <select id="data-file" name="data_file"></select>
            </div>
            <div>&nbsp;</div>
            <!-- Dropdown for the variables associated with the selected data file -->
            <div>
                <label for="data-vars">Variable:</label>
                <select id="data-vars" name="data_vars">
                    <option value="vs">vs</option>
                    <option value="rho">rho</option>
                </select>
            </div>
            <div>&nbsp;</div>
            <div class="sliderContainer">
                <label class="sliderLabel">Min Latitude: <input type="range" id="minLatSlider" min="47" max="50.9"
                        step="0.1" value="47"></label>
                <span id="minLatValue">47</span>
            </div>
            <div class="sliderContainer">
                <label class="sliderLabel">Max Latitude: <input type="range" id="maxLatSlider" min="47" max="50.9"
                        step="0.1" value="50.9"></label>
                <span id="maxLatValue">50.9</span>
            </div>
            <div class="sliderContainer">
                <label class="sliderLabel">Min Longitude: <input type="range" id="minLonSlider" min="-126" max="-121.1"
                        step="0.1" value="-126"></label>
                <span id="minLonValue">-126</span>
            </div>
            <div class="sliderContainer">
                <label class="sliderLabel">Max Longitude: <input type="range" id="maxLonSlider" min="-126" max="-121.1"
                        step="0.1" value="-121.1"></label>
                <span id="maxLonValue">-121.1</span>
            </div>
            <div class="sliderContainer">
                <label class="sliderLabel">Depth (km): <input type="range" id="minDepthSlider" min="0" max="93" step="1"
                        value="0"></label>
                <span id="minDepthValue">0</span>
            </div>
            <!-- I tried implementing a diagonal slice toggle and slider, but I have not been able to get it working yet -->
            <!--div id="toggleDiagSlice"-->
                <!--label-->
                    <!--input type="checkbox" id="toggleDiagSliceCheckbox">Diagonal Slice-->
                <!--/label-->
            <!--/div-->
            <!--div class="sliderContainer"-->
                <!--label class="sliderLabel">Diagonal Slice (%): <input type="range" id="diagSlider" min="0" max="100" step="1"
                        value="0"--><!--/label-->
                <!--span id="diagValue">0</span-->
            <!--/div-->

            <!-- Change the maxDepthSlider so it appears on the webpage which allows me to add the other sides of the bounding box to the globe -->
            <!--div class="sliderContainer" style="display: none;"-->
            <div class="sliderContainer">
                <label class="sliderLabel">Max Depth (km): <input type="range" id="maxDepthSlider" min="0" max="93"
                        step="1" value="93"></label>
                <span id="maxDepthValue">93</span>
            </div>
            <div class="sliderContainer">
                <label class="sliderLabel">Alpha: <input type="range" id="alphaSlider" min="0" max="1" step="0.1"
                        value="0.3"></label>
                <span id="alphaValue">0.3</span>
            </div>
            <button type="button" class="button" id="sync-to-parent">Sync to Form</button>
        </form>

    </div>

    <div id="mapControls">
        <div id="logoContainer">
            <img src="/static/images/crescent_logos_horizontal_transparent.png" alt="Logo">
        </div>
        <div id="legendContainer"></div>
        <div id="auxLegendContainer"></div>
        <div id="distanceControl">
            <label><input type="checkbox" id="clearCheckbox"> Measure Distance</label>
            <div id="distanceDisplay">Click distances will appear here</div>
        </div>
    </div>

    <script>

        Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmZDQzMzIyOS1lZDFlLTRhNTgtYTE1Yy04YzNkNWQ2ZmI4OTIiLCJpZCI6MjAxODU5LCJpYXQiOjE3MTA0MDQ5MDd9._E6MFZMMjbxpzC4qYYROP1ldtV1MJn0f56W5woAtboc";
        const apiKey = "AAPKafd67a0544f04817b08c2f65379b76c8pz3w8RSH_npDJjf9phbqEJ2kbD8QnfX-lzVlJ7dUi_3pQjwWS-vNFeXT6jacicfJ";

        var viewer = new Cesium.Viewer('cesiumContainer', {
            depthPlaneEllipsoidOffset: 10000,
            nearToFarRatio: 1e6,
            farToNearRatio: 1e-6,
            sceneMode: Cesium.SceneMode.SCENE3D,
            scene3DOnly: true,
            enableCollisionDetection: false,
            baseLayer: Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3813)),
            globe: new Cesium.Globe(Cesium.Ellipsoid.WGS84, {
                minimumZoomDistance: 0.0
            })
        });

        // Function to read and clear an item from localStorage
        function readAndClearLocalStorageItem(key) {
            // Step 1: Read the item from localStorage
            const item = localStorage.getItem(key);

            // Step 2: Remove the item from localStorage
            localStorage.removeItem(key);

            // Step 3: Return the parsed item, or null if it doesn't exist
            return item !== null ? JSON.parse(item) : null;
        }

        // Usage example to get selectedLines
        const selectedLines = readAndClearLocalStorageItem('selectedLines') || [];
        if (selectedLines.length != 0) {
            console.log('Selected lines:', selectedLines);
        }

        viewer.scene.globe.frontFaceAlphaByDistance = new Cesium.NearFarScalar(50.0, 0.0, 100.0, 1.0);
        viewer.scene.globe.show = false;
        viewer.scene.skyAtmosphere.show = false;
        viewer.scene.fog.enabled = false;
        viewer.scene.globe.showGroundAtmosphere = false;
        viewer.scene.globe.depthTestAgainstTerrain = true;

        const toggleTerrainOcclusionCheckbox = document.getElementById('toggleTerrainOcclusionCheckbox');
        toggleTerrainOcclusionCheckbox.addEventListener('change', function () {
            viewer.scene.globe.depthTestAgainstTerrain = toggleTerrainOcclusionCheckbox.checked;
        });

        viewer.scene.setTerrain(new Cesium.Terrain(Cesium.CesiumTerrainProvider.fromIonAssetId(2426648)));
        const scene = viewer.scene;
        const globe = scene.globe;
        const camera = scene.camera;

        scene.fog.enabled = false;
        globe.showGroundAtmosphere = false;
        globe.enableLighting = true;

        scene.light = new Cesium.DirectionalLight({
            direction: new Cesium.Cartesian3(1, 0, 0),
        });

        const scratchNormal = new Cesium.Cartesian3();
        scene.preRender.addEventListener(function (scene, time) {
            const surfaceNormal = globe.ellipsoid.geodeticSurfaceNormal(camera.positionWC, scratchNormal);
            const negativeNormal = Cesium.Cartesian3.negate(surfaceNormal, surfaceNormal);
            scene.light.direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.add(negativeNormal, camera.rightWC, surfaceNormal), scene.light.direction);
        });

        globe.maximumScreenSpaceError = 1.0;
        viewer.scene.backgroundColor = new Cesium.Color(0.0, 0.0, 0.0, 0.0);
        viewer.camera.flyTo({
            destination: Cesium.Rectangle.fromDegrees(-130.0, 39.0, -116.0, 52.0)
        });

        viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(-132.76, 39.84, 718005.890),
            orientation: {
                heading: Cesium.Math.toRadians(48.65),
                pitch: Cesium.Math.toRadians(-36.05),
                roll: 0.3
            }
        });

        viewer.scene.globe.baseColor = Cesium.Color.TRANSPARENT;
        viewer.animation.container.style.visibility = 'hidden';
        viewer.timeline.container.style.visibility = 'hidden';

        var dataSources = [];
        const auxData = ["https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/cascadia_subduction_interface_temp.geojson"];
        const auxLabel = ["Cascadia Subduction Interface", "CVM Coverage"];
        const auxColor = [Cesium.Color.GREEN, Cesium.Color.BLUE];
        const auxFillOpacity = [0.5, 0.5];
        const auxLineWidth = [4, 4];

        var data = ['/static/boundary_geojson/us-states.json', '/static/boundary_geojson/georef-canada-province-public.geojson', 'https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/crescent_cfm_crustal_traces.geojson', 'https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/crescent_cfm_crustal_3d.geojson'];
        var label = ['US', 'Canada', 'CRESCENT Cascadia Fault Traces', 'CRESCENT Cascadia Fault Surfaces', 'Earthquakes M > 4'];
        const geojson_files = ['https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/crescent_cfm_crustal_traces.geojson', 'https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/crescent_cfm_crustal_3d.geojson']
        const dataColor = [Cesium.Color.GRAY, Cesium.Color.DIMGRAY, Cesium.Color.CRIMSON, Cesium.Color.DARKMAGENTA, Cesium.Color.YELLOW];
        const fillOpacity = [0.0, 0.0, 0.5, 0.5];
        const lineWidth = [2, 0.5, 2, 2];

        // Really need only one variable, but my attempts at merging them was drawing extra diagonal line.
        var boxEntityTop;
        var boxEntityBottom;
        var boxEntityEdge1;
        var boxEntityEdge2;
        var boxEntityEdge3;
        var boxEntityEdge4;
        //var boxEntityDiag;

        async function loadDropdown() {
            try {
                const response = await fetch('/models_drop_down');
                if (response.ok) {
                    const dropdownHTML = await response.text();
                    document.getElementById('data-file').innerHTML = dropdownHTML;
                } else {
                    console.error('Failed to load dropdown:', response.statusText);
                    document.getElementById('data-file').textContent = 'Failed to load dropdown.';
                }
            } catch (error) {
                console.error('Error fetching dropdown:', error);
                document.getElementById('data-file').textContent = 'Error loading dropdown.';
            }

        }

        //select an option from a <select> menu based on the optionâ€™s text
        function selectOptionByText(text) {
            const selectElement = document.getElementById('data-file');
            const options = selectElement.options;

            for (let i = 0; i < options.length; i++) {
                if (options[i].text === text) {
                    selectElement.selectedIndex = i;
                    optionFound = true;

                    // Trigger the change event
                    updateSlidersFromDropdown();

                    return;
                }
            }

            alert('Option not found: ' + text);
        }



        // Send message to the parent indicating ready to sync.
        document.addEventListener('DOMContentLoaded', function () {
            const iframeForm = document.getElementById('iframe-form');

            // Function to send the current form data to the parent
            function syncToParent() {
                const formData = new FormData(iframeForm);
                const data = {};
                formData.forEach((value, key) => {
                    data[key] = value;
                });

                window.parent.postMessage({
                    type: 'syncFromIframe',
                    data
                }, window.location.origin);
            }

            // Function to handle messages from the parent
            window.addEventListener('message', function (event) {
                if (event.origin !== window.location.origin) {
                    return; // Ignore messages from other origins for security
                }
                if (event.data.type === 'syncFromParent') {
                    function copyIframeFormValues() {
                        const data = event.data.data;

                        // The model selection update.
                        selectOptionByText(data['data-file'])

                        // Sliders update.
                        document.getElementById('minLonSlider').value = data['start-lng'];
                        document.getElementById('maxLonSlider').value = data['end-lng'];
                        document.getElementById('minLatSlider').value = data['start-lat'];
                        document.getElementById('maxLatSlider').value = data['end-lat'];
                        document.getElementById('minDepthSlider').value = data['start-depth'];
                        

                        // Slider labels update.
                        document.getElementById('minLonValue').textContent = data['start-lng'];
                        document.getElementById('maxLonValue').textContent = data['end-lng'];
                        document.getElementById('minLatValue').textContent = data['start-lat'];
                        document.getElementById('maxLatValue').textContent = data['end-lat'];
                        document.getElementById('minDepthValue').textContent = data['start-depth'];

                        // Update the outline box.
                        updateBoxOutline(parseFloat(minLatSlider.value), parseFloat(maxLatSlider.value), parseFloat(minLonSlider.value), parseFloat(maxLonSlider.value), parseFloat(minDepthSlider.value), parseFloat(maxDepthSlider.value), parseFloat(document.getElementById('alphaSlider').value));


                    }
                    copyIframeFormValues();

                }

                if (event.data.type === 'requestSyncToParent') {
                    syncToParent();
                }
            });

            // Sync to parent button
            document.getElementById('sync-to-parent').addEventListener('click', syncToParent);
        });



        // Call loadDropdown when the page has finished loading
        document.addEventListener('DOMContentLoaded', loadDropdown);


        for (var i = 0; i < data.length; i++) {
            (function (index) {
                const dataSource = Cesium.GeoJsonDataSource.load(data[index], {
                    label: label[index],
                    stroke: dataColor[index],
                    fill: dataColor[index].withAlpha(fillOpacity[index]),
                    strokeWidth: lineWidth[index],
                    markerSymbol: '?'
                });
                dataSource.then(function (dataSource) {
                    var entitiesToRemove = [];
                    dataSource.entities.values.forEach(function (entity) {
                        var ok = true;
                        // Display all if selectedLines is empty.
                        if (selectedLines.length != 0) {
                            if (geojson_files.includes(data[index]) && !selectedLines.includes(String(entity.properties.id))) {
                                ok = false;
                                entitiesToRemove.push(entity);
                            }
                        }
                        if (ok) {
                            if (Cesium.defined(entity.polygon)) {
                                var coordinates = entity.polygon.hierarchy.getValue().positions;
                                coordinates.forEach(function (coordinate) {
                                    Cesium.Cartographic.fromCartesian(coordinate);
                                });
                            } else if (Cesium.defined(entity.polyline)) {
                                var positions = entity.polyline.positions.getValue();
                                positions.forEach(function (position) {
                                    Cesium.Cartographic.fromCartesian(position);
                                });
                            }
                            var description = '';
                            var properties = entity.properties;
                            for (var propertyName in properties) {
                                if (properties.hasOwnProperty(propertyName) && typeof properties[propertyName] !== 'function') {
                                    var propNameWithoutUnderscore = propertyName.replace(/^_/, '');
                                    description += propNameWithoutUnderscore + ': ' + properties[propertyName] + '<br />';
                                }
                            }
                            entity.description = description;
                        }
                    });

                    entitiesToRemove.forEach(function (entity) {
                        dataSource.entities.remove(entity);
                    });

                    dataSources.push(dataSource);
                    viewer.dataSources.add(dataSource);
                });

                if (i == 0) {
                    async function loadEarthquakeData(url) {
                        try {
                            const dataSource = await Cesium.GeoJsonDataSource.load(url, {
                                clampToGround: false
                            });
                            earthquakeDataSource = dataSource;
                            viewer.dataSources.add(dataSource);
                            updateEarthquakeVisibility();

                            const entities = dataSource.entities.values;
                            const circleSizeSlider = document.getElementById('circleSizeSlider');
                            entities.forEach(function (entity) {
                                entity.billboard = undefined;
                                if (entity.position) {
                                    let coordinates = Cesium.Cartographic.fromCartesian(entity.position.getValue(Cesium.JulianDate.now()));
                                    let depthInMeters = coordinates.height * 1000;
                                    entity.position = new Cesium.ConstantPositionProperty(Cesium.Cartesian3.fromDegrees(
                                        Cesium.Math.toDegrees(coordinates.longitude),
                                        Cesium.Math.toDegrees(coordinates.latitude),
                                        -depthInMeters
                                    ));
                                }
                                entity.point = new Cesium.PointGraphics({
                                    pixelSize: calculateMarkerSize(circleSizeSlider.value, entity.properties.mag.getValue()),
                                    color: Cesium.Color.YELLOW
                                });
                            });
                        } catch (error) {
                            console.log('Error loading earthquake data:', error);
                        }
                    }

                    loadEarthquakeData('https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=1970-01-01&minmagnitude=4&minlatitude=30&maxlatitude=50&minlongitude=-125&maxlongitude=-100');

                    function updateEarthquakeVisibility() {
                        if (earthquakeDataSource) {
                            var showEarthquakes = document.getElementById('showEarthquakesCheckbox').checked;
                            earthquakeDataSource.show = showEarthquakes;
                        }
                    }

                    document.getElementById('showEarthquakesCheckbox').addEventListener('change', updateEarthquakeVisibility);

                    function calculateMarkerSize(baseSize, magnitude) {
                        const scaleFactor = 3;
                        return baseSize * Math.pow(magnitude, scaleFactor);
                    }

                    document.getElementById('circleSizeSlider').addEventListener('input', function () {
                        if (earthquakeDataSource) {
                            var entities = earthquakeDataSource.entities.values;
                            entities.forEach(function (entity) {
                                entity.point = new Cesium.PointGraphics({
                                    color: Cesium.Color.YELLOW,
                                    pixelSize: calculateMarkerSize(circleSizeSlider.value, entity.properties.mag)
                                });
                            });
                        }
                    });
                }
            })(i);
        }

        var legendContainer = document.getElementById('legendContainer');
        label.forEach(function (labelText, i) {
            var legendItem = document.createElement('div');
            legendItem.classList.add('legendItem');

            var legendColor = document.createElement('div');
            legendColor.classList.add('legendColor');
            legendColor.style.backgroundColor = dataColor[i].toCssColorString();

            var legendLabel = document.createElement('span');
            legendLabel.textContent = labelText;

            legendItem.appendChild(legendColor);
            legendItem.appendChild(legendLabel);
            legendContainer.appendChild(legendItem);
        });

        var auxLegendContainer = document.getElementById('auxLegendContainer');
        auxColor.forEach(function (color, i) {
            var legendItem = document.createElement('div');
            legendItem.classList.add('legendItem');

            var legendColor = document.createElement('div');
            legendColor.classList.add('legendColor');
            legendColor.style.backgroundColor = color.toCssColorString();

            var legendLabel = document.createElement('span');
            legendLabel.textContent = auxLabel[i];

            legendItem.appendChild(legendColor);
            legendItem.appendChild(legendLabel);
            auxLegendContainer.appendChild(legendItem);
        });
        
        // Update the options given in the data-file and data-vars dropdown menus
        // when the webpage is first loaded.
        async function loadDropdown() {
            // Try to update the data-file dropdown options based on what is in the 
            // http://0.0.0.0:8000/models_drop_down_coverage page
            try {
                const response = await fetch('/models_drop_down_coverage');
                if (response.ok) {
                    const dropdownHTML = await response.text();
                    document.getElementById('data-file').innerHTML = dropdownHTML;
                    // Initialize sliders based on the first dropdown option
                    updateSlidersFromDropdown();
                } else {
                    console.error('Failed to load dropdown:', response.statusText);
                    document.getElementById('data-file').textContent = 'Failed to load dropdown.';
                }
            } catch (error) {
                console.error('Error fetching dropdown:', error);
                document.getElementById('data-file').textContent = 'Error loading dropdown.';
            }
            // Try to update the data-vars dropdown options based on what is in the 
            // http://0.0.0.0:8000/vis/models_drop_down page and which file was selected
            // in the data-file dropdown menu
            try {
                const response_var = await fetch('/vis/models_drop_down');
                if (response_var.ok) {
                    const dropdownvarHTML = await response_var.text();
                    var selected_data_set = document.getElementById('data-file').options[document.getElementById('data-file').selectedIndex].text;
                    const dropdownvarHTML_list = dropdownvarHTML.split("<option ");

                    const dropdown_models = [];
                    const dropdown_variables = [];

                    // Isolate the model names and their associated variables from the models
                    // listed in http://0.0.0.0:8000/vis/models_drop_down and input each of them into an array
                    for (var i = 0; i < dropdownvarHTML_list.length; i++) {
                        if (dropdownvarHTML_list[i].length > 0) {
                            const model = dropdownvarHTML_list[i].split(">")[1].replace("</option", "");
                            const model_name = model.split(" ")[0];
                            const model_vars = model.split(" ")[1];
                            dropdown_models.push(model_name);
                            dropdown_variables.push(model_vars);  
                        }
                    }

                    // Get the array of variables that are associated with the model selected in the data-file dropdown
                    let selected_data_set_vars = ['vs'];

                    for (var i = 0; i < dropdown_models.length; i++) {
                        if (dropdown_models[i] == selected_data_set) {
                            selected_data_set_vars = dropdown_variables[i].replace("(", "").replace(")", "").split(",");
                        }
                    }

                    // Add the HTML information back to the variable options
                    for (var i = 0; i < selected_data_set_vars.length; i++) {
                         selected_data_set_vars[i] = "<option value=\"" + selected_data_set_vars[i] + "\">" + selected_data_set_vars[i] + "</option>";
                    }
                    // Update the data-vars dropdown options        
                    document.getElementById('data-vars').innerHTML = selected_data_set_vars.join(" ");
                    // Initialize sliders based on the first dropdown option
                    updateSlidersFromDropdown();
                } else {
                    console.error('Failed to load variable dropdown:', response_var.statusText);
                    document.getElementById('data-vars').textContent = 'Failed to load variable dropdown.';
                }
            } catch (error) {
                console.error('Error fetching variable dropdown:', error);
                document.getElementById('data-vars').textContent = 'Error loading variable dropdown.';
            }
        }
        // Update the options given in the data-vars dropdown menu after the webpage has finished
        // loading for the first time (this function is called every time the selected model in the
        // data-file dropdown menu changes).
        async function loadVarDropdown() {
            // Try to update the data-vars dropdown options based on what is in the 
            // http://0.0.0.0:8000/vis/models_drop_down page and which file was selected
            // in the data-file dropdown menu
            try {
                const response_var = await fetch('/vis/models_drop_down');
                if (response_var.ok) {
                    const dropdownvarHTML = await response_var.text();
                    var selected_data_set = document.getElementById('data-file').options[document.getElementById('data-file').selectedIndex].text;
                    const dropdownvarHTML_list = dropdownvarHTML.split("<option ");

                    const dropdown_models = [];
                    const dropdown_variables = [];

                    // Isolate the model names and their associated variables from the models
                    // listed in http://0.0.0.0:8000/vis/models_drop_down and input each of them into an array
                    for (var i = 0; i < dropdownvarHTML_list.length; i++) {
                        if (dropdownvarHTML_list[i].length > 0) {
                            const model = dropdownvarHTML_list[i].split(">")[1].replace("</option", "");
                            const model_name = model.split(" ")[0];
                            const model_vars = model.split(" ")[1];
                            dropdown_models.push(model_name);
                            dropdown_variables.push(model_vars);  
                        }
                    }

                    // Get the array of variables that are associated with the model selected in the data-file dropdown
                    let selected_data_set_vars = ['vs'];

                    for (var i = 0; i < dropdown_models.length; i++) {
                        if (dropdown_models[i] == selected_data_set) {
                            selected_data_set_vars = dropdown_variables[i].replace("(", "").replace(")", "").split(",");
                        }
                    }
                            

                    // Add the HTML information back to the variable options
                    for (var i = 0; i < selected_data_set_vars.length; i++) {
                         selected_data_set_vars[i] = "<option value=\"" + selected_data_set_vars[i] + "\">" + selected_data_set_vars[i] + "</option>";
                    }

                    // Update the data-vars dropdown options        
                    document.getElementById('data-vars').innerHTML = selected_data_set_vars.join(" ");
                    // Initialize sliders based on the first dropdown option
                    updateSlidersFromDropdown();
                } else {
                    console.error('Failed to load variable dropdown:', response_var.statusText);
                    document.getElementById('data-vars').textContent = 'Failed to load variable dropdown.';
                }
            } catch (error) {
                console.error('Error fetching variable dropdown:', error);
                document.getElementById('data-vars').textContent = 'Error loading variable dropdown.';
            }
        }

        // Call loadDropdown when the page has finished loading
        document.addEventListener('DOMContentLoaded', loadDropdown);

        // Function that updates the dimensions of each side of the bounding box and the slice images shown
        async function updateBoxOutline(minLat, maxLat, minLon, maxLon, minDepth, maxDepth, alpha) {
            // Clear all items in localStorage for the current origin
            localStorage.clear();

            // Clear all items in sessionStorage for the current origin (session-specific)
            sessionStorage.clear();
            // fetch the json file with the information about the group of slice images
            var data_set = document.getElementById('data-file').options[document.getElementById('data-file').selectedIndex].text;
            var data_var = document.getElementById('data-vars').options[document.getElementById('data-vars').selectedIndex].text;
            var jsonFile = '../static/json/LP4.json';

            if (data_set == 'Cascadia_ANT+RF_Delph2018') {
                jsonFile = '../static/json/LP4.json';
            } else if (data_set == 'SVI_EQTOMO_Savard2018') {
                jsonFile = '../static/json/LP6.json';
            } else {  // I plan to add the casc1.6_velmdl slices to the webpage later
                console.log("The data set selected is not available");
            }
            var numImgs = 0;
            var dirName = '';
            var imgStem = '';
            var minPer = 0;
            var lonNumImgs = 0;
            var lonDirName = '';
            var lonImgStem = '';
            var lonMinPer = 0;
            var latNumImgs = 0;
            var latDirName = '';
            var latImgStem = '';
            var latMinPer = 0;
            var jsonData = {};

            // Try to read the json file
            try {
                const response = await fetch(jsonFile);
                if (!response.ok) {
                    throw new Error('Failed to load JSON: ${response.statusText}');
                }
                jsonData = await response.json();

                // Extract JSON values or set them to default values (if they don't exist)
                
                numImgs = jsonData.num_images || 1;
                dirName = jsonData.dir_name || '';
                imgStem = jsonData.img_stem || '';
                minPer = jsonData.min_per || 0;
                lonNumImgs = jsonData.lon_axis_num_images || 1;
                lonDirName = jsonData.lon_axis_dir_name || '';
                lonImgStem = jsonData.lon_axis_img_stem || '';
                lonMinPer = jsonData.lon_axis_min_per || 0;
                latNumImgs = jsonData.lat_axis_num_images || 1;
                latDirName = jsonData.lat_axis_dir_name || '';
                latImgStem = jsonData.lat_axis_img_stem || '';
                latMinPer = jsonData.lat_axis_min_per || 0;

            } catch (e) {
                console.error("Error processing JSON data:", e);
                // If JSON data is critical and corrupted, prevent further rendering
                return;
            }


            // Assuming the JSON structure matches your form fields' ids
            for (const [key, value] of Object.entries(jsonData)) {
                if (key === "num_images") {
                    numImgs = value;
                }
                if (key === "dir_name") {
                    dirName = value;
                }
                if (key === "img_stem") {
                    imgStem = value;
                }
                if (key === "min_per") {
                    minPer = value;
                }
                if (key === "lon_axis_num_images") {
                    lonNumImgs = value;
                }
                if (key === "lon_axis_dir_name") {
                    lonDirName = value;
                }
                if (key === "lon_axis_img_stem") {
                    lonImgStem = value;
                }
                if (key === "lon_axis_min_per") {
                    lonMinPer = value;
                }
                if (key === "lat_axis_num_images") {
                    latNumImgs = value;
                }
                if (key === "lat_axis_dir_name") {
                    latDirName = value;
                }
                if (key === "lat_axis_img_stem") {
                    latImgStem = value;
                }
                if (key === "lat_axis_min_per") {
                    latMinPer = value;
                }
            }

            // Coordinates for the four corners.
            var positions = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, minDepth * -1000,  // Longitude, Latitude, Height
                maxLon, minLat, minDepth * -1000,
                maxLon, maxLat, minDepth * -1000,
                minLon, maxLat, minDepth * -1000,
            ]);


            // Coordinates for the four corners for the bottom side of the bounding box.
            var positionsBot = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, maxDepth * -1000,  // Longitude, Latitude, Height
                maxLon, minLat, maxDepth * -1000,
                maxLon, maxLat, maxDepth * -1000,
                minLon, maxLat, maxDepth * -1000,
            ]);


            // Coordinates for the four corners for the edge 1 of the bounding box.
            var positionsEdge1 = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, minDepth * -1000,  // Longitude, Latitude, Height
                minLon, minLat, maxDepth * -1000,
                minLon, maxLat, maxDepth * -1000,
                minLon, maxLat, minDepth * -1000,
            ]);


            // Coordinates for the four corners for the edge 2 of the bounding box.
            var positionsEdge2 = Cesium.Cartesian3.fromDegreesArrayHeights([
                maxLon, minLat, minDepth * -1000,  // Longitude, Latitude, Height
                maxLon, minLat, maxDepth * -1000,
                maxLon, maxLat, maxDepth * -1000,
                maxLon, maxLat, minDepth * -1000,
            ]);
            

            // Coordinates for the four corners for the edge 3 of the bounding box.
            var positionsEdge3 = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, minDepth * -1000,  // Longitude, Latitude, Height
                minLon, minLat, maxDepth * -1000,
                maxLon, minLat, maxDepth * -1000,
                maxLon, minLat, minDepth * -1000,
            ]);


            // Coordinates for the four corners for the edge 4 of the bounding box.
            var positionsEdge4 = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, maxLat, minDepth * -1000,  // Longitude, Latitude, Height
                minLon, maxLat, maxDepth * -1000,
                maxLon, maxLat, maxDepth * -1000,
                maxLon, maxLat, minDepth * -1000,
            ]);

            // Remove any previous primitives that were added to the scene from a previous call to updateBoxOutline
            if (boxEntityTop !== null) {
                viewer.scene.primitives.remove(boxEntityTop);
            }
            if (boxEntityBottom !== null) {
                viewer.scene.primitives.remove(boxEntityBottom);
            }
            if (boxEntityEdge1 !== null) {
                viewer.scene.primitives.remove(boxEntityEdge1);
            }
            if (boxEntityEdge2 !== null) {
                viewer.scene.primitives.remove(boxEntityEdge2);
            }
            if (boxEntityEdge3 !== null) {
                viewer.scene.primitives.remove(boxEntityEdge3);
            }
            if (boxEntityEdge4 !== null) {
                viewer.scene.primitives.remove(boxEntityEdge4);
            }


            const minDepthSliderTest = document.getElementById('minDepthSlider');
            const maxDepthSliderTest = document.getElementById('maxDepthSlider');
            const minLonSliderTest = document.getElementById('minLonSlider');
            const maxLonSliderTest = document.getElementById('maxLonSlider');
            const minLatSliderTest = document.getElementById('minLatSlider');
            const maxLatSliderTest = document.getElementById('maxLatSlider');
            const alphaSliderVal = document.getElementById('alphaSlider');

            // I was testing out my diagonal slider here to see if I could get it working
            //const diagSliderTest = document.getElementById('diagSlider');
            //console.log("Diagonal Slider value: ", diagSliderTest.value);
            //console.log("Diagonal Slider min value: ", diagSliderTest.min);
            //console.log("Diagonal Slider max value: ", diagSliderTest.max);

            
            var minDepthTest = minDepthSliderTest.min;
            var maxDepthTest = maxDepthSliderTest.max;
            var minLonTest = minLonSliderTest.min;
            var maxLonTest = maxLonSliderTest.max;
            var minLatTest = minLatSliderTest.min;
            var maxLatTest = maxLatSliderTest.max;

            var depthDiff = minDepthSliderTest.value - minDepthTest;
            var depthRange = (maxDepthTest - minDepthTest) + 1;

            // Function that takes in the stem of the image name, the minimum percentage slice
            // in VisIt where the slice contains data (which corresponds to the lowest number 
            // at the end of the file name in the sequence of y-axis slices), the current value
            // of the depth slider, the minimum and maximum values of the depth slider, the 
            // number of y-axis slice images and the variable selected in the data-vars dropdown
            // to return part of the file path and image name for the image that will be used as the
            // texture for the bounding box side
            function getImageName(stem, minPer, depth, minDepth, maxDepth, numImages, varName) {

	        var depthDiff = depth - minDepth;
                var depthRange = (maxDepth - minDepth) + 1;
            
                let depthImgsStep;
                if (numImages <= 1) { // If only one image or zero images, step is irrelevant, assume index 0/minPer
                    depthImgsStep = 1;
                } else {
                    depthImgsStep = (depthRange * 1.0) / (numImages);
                    if (depthImgsStep === 0) { // If range is 0, but multiple images, step still 0, avoid division by zero
                        depthImgsStep = 1; // Assume only first image relevant if no range
                    }
                }

                var depthImgsIndx = minPer + Math.round(depthDiff/depthImgsStep);

                // Clamp the index to valid bounds based on numImages and minPer
                const maxValidIndex = minPer + numImages - 1;
        
                if (depthImgsIndx < minPer) {
                    depthImgsIndx = minPer;
                } else if (depthImgsIndx > maxValidIndex) {
                    depthImgsIndx = maxValidIndex;
                }

                console.assert(Number.isInteger(depthImgsIndx) && depthImgsIndx >= 0, '[getImageName: ' + varName + '] Final index is not a valid non-negative integer!');

                const texturePath = varName + '/' + varName + '_' + stem + depthImgsIndx + '.png';
                return texturePath;

            }
            // Function that takes in the stem of the image name, the minimum percentage slice
            // in VisIt where the slice contains data (which corresponds to the lowest number 
            // at the end of the file name in the sequence of x-axis or z-axis slices), the current value
            // of the lat/lon slider, the minimum and maximum values of the lat/lon slider, the 
            // number of x-axis or z-axis slice images and the variable selected in the data-vars dropdown
            // to return part of the file path and image name for the image that will be used as the
            // texture for the bounding box side
            function getLonLatImageName(stem, minPer, value, minVal, maxVal, numImages, varName) {

	        var valDiff = value - minVal;
                var valRange = (maxVal - minVal);
            
                let valImgsStep;
                if (numImages <= 1) { // If only one image or zero images, step is irrelevant, assume index 0/minPer
                    valImgsStep = 1;
                } else {
                    valImgsStep = (valRange * 1.0) / (numImages);
                    if (valImgsStep === 0) { // If range is 0, but multiple images, step still 0, avoid division by zero
                        valImgsStep = 1; // Assume only first image relevant if no range
                    }
                }

                var valImgsIndx = minPer + Math.round(valDiff/valImgsStep);

                // Clamp the index to valid bounds based on numImages and minPer
                const maxValidIndex = minPer + numImages - 1;
        
                if (valImgsIndx < minPer) {
                    valImgsIndx = minPer;
                } else if (valImgsIndx > maxValidIndex) {
                    valImgsIndx = maxValidIndex;
                }

                console.assert(Number.isInteger(valImgsIndx) && valImgsIndx >= 0, '[getLonLatImageName: ' + varName + '] Final index is not a valid non-negative integer!');

                const texturePath = varName + '/' + varName + '_' + stem + valImgsIndx + '.png';
                return texturePath;

            }

            minDepthTest = parseFloat(minDepthTest);
            maxDepthTest = parseFloat(maxDepthTest);
            minLonTest = parseFloat(minLonTest);
            maxLonTest = parseFloat(maxLonTest);
            minLatTest = parseFloat(minLatTest);
            maxLatTest = parseFloat(maxLatTest);

            // Get the file paths and slice image names for the images that will be used as textures for all six sides of the bounding box
            var textureImg = dirName.concat(getImageName(imgStem, minPer, parseFloat(minDepthSliderTest.value), minDepthTest, maxDepthTest, numImgs, data_var));
            
            var textureImgBot = dirName.concat(getImageName(imgStem, minPer, parseFloat(maxDepthSliderTest.value), minDepthTest, maxDepthTest, numImgs, data_var));

            var textureImgEdge1 = lonDirName.concat(getLonLatImageName(lonImgStem, lonMinPer, parseFloat(minLonSliderTest.value), minLonTest, maxLonTest, lonNumImgs, data_var));

            var textureImgEdge2 = lonDirName.concat(getLonLatImageName(lonImgStem, lonMinPer, parseFloat(maxLonSliderTest.value), minLonTest, maxLonTest, lonNumImgs, data_var));

            var textureImgEdge3 = latDirName.concat(getLonLatImageName(latImgStem, latMinPer, parseFloat(minLatSliderTest.value), minLatTest, maxLatTest, latNumImgs, data_var));

            var textureImgEdge4 = latDirName.concat(getLonLatImageName(latImgStem, latMinPer, parseFloat(maxLatSliderTest.value), minLatTest, maxLatTest, latNumImgs, data_var));


            var numPositions = 4;
            var pos = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          pos[i * 3] = positions[i].x;
                          pos[i * 3 + 1] = positions[i].y;
                          pos[i * 3 + 2] = positions[i].z;
                      }

            var posBot = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posBot[i * 3] = positionsBot[i].x;
                          posBot[i * 3 + 1] = positionsBot[i].y;
                          posBot[i * 3 + 2] = positionsBot[i].z;
                      }

            var posEdge1 = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posEdge1[i * 3] = positionsEdge1[i].x;
                          posEdge1[i * 3 + 1] = positionsEdge1[i].y;
                          posEdge1[i * 3 + 2] = positionsEdge1[i].z;
                      }
            var posEdge2 = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posEdge2[i * 3] = positionsEdge2[i].x;
                          posEdge2[i * 3 + 1] = positionsEdge2[i].y;
                          posEdge2[i * 3 + 2] = positionsEdge2[i].z;
                      }
            var posEdge3 = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posEdge3[i * 3] = positionsEdge3[i].x;
                          posEdge3[i * 3 + 1] = positionsEdge3[i].y;
                          posEdge3[i * 3 + 2] = positionsEdge3[i].z;
                      }
            var posEdge4 = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posEdge4[i * 3] = positionsEdge4[i].x;
                          posEdge4[i * 3 + 1] = positionsEdge4[i].y;
                          posEdge4[i * 3 + 2] = positionsEdge4[i].z;
                      }

            // Calculate the UV coordinates to determine how the images should be mapped to the sides of the bounding box
            var min_x_ratio = (minLon - minLonSliderTest.min)/(maxLonSliderTest.max - minLonSliderTest.min);
            var max_x_ratio = (maxLon - maxLonSliderTest.min)/(maxLonSliderTest.max - minLonSliderTest.min);
            var min_y_ratio = (minLat - minLatSliderTest.min)/(maxLatSliderTest.max - minLatSliderTest.min);
            var max_y_ratio = (maxLat - maxLatSliderTest.min)/(maxLatSliderTest.max - minLatSliderTest.min);
            var uvs = [min_x_ratio, min_y_ratio, max_x_ratio, min_y_ratio, max_x_ratio, max_y_ratio, min_x_ratio, max_y_ratio];
            var indexs = new Uint16Array([0, 1, 2, 2, 3, 0]);
            var min_z_ratio = (minDepth - minDepthSliderTest.min)/(maxDepthSliderTest.max - minDepthSliderTest.min);
            var max_z_ratio = (maxDepth - maxDepthSliderTest.min)/(maxDepthSliderTest.max - minDepthSliderTest.min);
            var uvsEdge1 = [min_z_ratio, min_y_ratio, max_z_ratio, min_y_ratio, max_z_ratio, max_y_ratio, min_z_ratio, max_y_ratio];

            var uvsEdge3 = [min_z_ratio, min_x_ratio, max_z_ratio, min_x_ratio, max_z_ratio, max_x_ratio, min_z_ratio, max_x_ratio];
        
            // Create the geometry for each of the six primitives (one for each bounding box side)
            var geometry = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: pos
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvs
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(pos)
            });

            var geometryBot = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posBot
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvs
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posBot)
            });


            var geometryEdge1 = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posEdge1
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvsEdge1
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posEdge1)
            });
            
            var geometryEdge2 = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posEdge2
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvsEdge1
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posEdge2)
            });

            var geometryEdge3 = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posEdge3
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvsEdge3
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posEdge3)
            });

            var geometryEdge4 = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posEdge4
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvsEdge3
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posEdge4)
            });

            // Create the geometry instances for each bounding box side
            var myInstance = new Cesium.GeometryInstance({
                geometry: geometry,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceBot = new Cesium.GeometryInstance({
                geometry: geometryBot,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceEdge1 = new Cesium.GeometryInstance({
                geometry: geometryEdge1,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceEdge2 = new Cesium.GeometryInstance({
                geometry: geometryEdge2,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceEdge3 = new Cesium.GeometryInstance({
                geometry: geometryEdge3,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceEdge4 = new Cesium.GeometryInstance({
                geometry: geometryEdge4,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
   
            try {
                // Create the Cesium material for the mimimum depth slice bounding box side
                var fetchedImg;
                topMaterial = new Cesium.Material({
                  fabric : {
                      type : 'MyCustomMap',
                      uniforms : {
                          image : '',
                          color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                      },
                      components : {
                          emission : 'texture(image, materialInput.st).rgb',
                          alpha : 'texture(image, materialInput.st).a * color.a'
                      }
                    },
                    translucent: true
                });

                // Add the minimum depth slice primitive/side to the scene
                boxEntityTop = viewer.scene.primitives.add(new Cesium.Primitive({
                    geometryInstances: myInstance,

                    id: 'boxEntity',

                    appearance: new Cesium.MaterialAppearance({
                        material : topMaterial,
                    }),
                    //asynchronous: false,
                    asynchronous: true,
                }));

                if (boxEntityTop) {
                    boxEntityTop.show = false; // Hide the primitive temporarily
                }
                viewer.allowDataSourcesToSuspendAnimation = true;
                // I tried to use a promise to try to force it to load the image before displaying it
                new Promise((resolve, reject) => {
                Cesium.Resource.fetchImage({url: textureImg}).then((image) => {
                    topMaterial.uniforms.image = image;
                    viewer.scene.requestRender();
                    // Show the primitive again after it's fully updated
                    boxEntityTop.show = true;
                    resolve('Texture loaded and applied');
                })
                .catch((error) => {
                    console.error('Error loading texture:', error);
                    reject(error); // Propagate error if loading fails
                });
                });
            } catch (error) {
                // Handle errors
                console.log(`There was an error while creating the top slice primitive. ${error}`);
            }

            // I tried to use Cesium.Resource.fetchImage before creating the boxEntityTop to see
            // if that would load the image before it tried to render it.
            /*

            console.log("Start");
            setTimeout(() => {
                console.log("Executed after 1 seconds");
            }, 1000); // 1000 milliseconds = 1 seconds

            console.log("End"); // This will log before the setTimeout callback
            var fetchedImg;
            Cesium.Resource.fetchImage({url: textureImg}).then(function(image) {
                //texture.copyFrom(image);
                fetchedImg = image;
                boxEntityTop = viewer.scene.primitives.add(new Cesium.Primitive({
                    geometryInstances: myInstance,

                    id: 'boxEntity',

                    appearance: new Cesium.MaterialAppearance({
                        material : new Cesium.Material({
                          fabric : {
                              type : 'MyCustomMap',
                              uniforms : {
                                  image : fetchedImg,
                                  color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                              },
                              components : {
                                  emission : 'texture(image, materialInput.st).rgb',
                                  alpha : 'texture(image, materialInput.st).a * color.a'
                              }
                            },
                            translucent: true
                        }),
                    }),
                    asynchronous: false,
                }));
            }).catch(function(error) {
                console.log(`There was an error while creating the top slice primitive. ${error}`);
            });
            */
            // I tried to use Cesium.Resource.fetchImage before creating the material for the boxEntityTop to see
            // if that would load the image before it tried to render it.
            /*
            // Use Cesium.Resource.fetchImage to load the image
            Cesium.Resource.fetchImage(textureImg)
                .then((loadedImage) => {
                    // Create a custom material with the loaded image
                    /*
                    const material = new Cesium.Material({
                        fabric: {
                            type: "Image",
                            uniforms: {
                                image: loadedImage
                            }
                        }
                    });
                    */
                    /*
                    topMaterial = new Cesium.Material({
                        fabric : {
                            type : 'MyCustomMap',
                            uniforms : {
                                image : loadedImage,
                                color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                            },
                            components : {
                                emission : 'texture(image, materialInput.st).rgb',
                                alpha : 'texture(image, materialInput.st).a * color.a'
                            }
                         },
                         translucent: true
                    });

                    if (boxEntityTop !== null) {
                        viewer.scene.primitives.remove(boxEntityTop);
                        //boxEntityTop.appearance.material.uniforms.image = loadedImage;
                    } //else {
                    */
                    // Create a primitive with a custom geometry
                    /*
                    const primitive = new Cesium.Primitive({
                        geometryInstances: new Cesium.GeometryInstance({
                            geometry: new Cesium.RectangleGeometry({
                                rectangle: Cesium.Rectangle.fromDegrees(-100.0, 30.0, -90.0, 40.0),
                                vertexFormat: Cesium.MaterialAppearance.VERTEX_FORMAT
                            })
                        }),
                        appearance: new Cesium.MaterialAppearance({
                            material: material,
                        })
                    });
                    */
                    /*
                    boxEntityTop = new Cesium.Primitive({
                        geometryInstances: myInstance,

                        id: 'boxEntity',

                        appearance: new Cesium.MaterialAppearance({
                            material : topMaterial,
                        }),
                        asynchronous: false,
                    });

                    //boxEntityTop.appearance.material.uniforms.image = loadedImage;

                    // Add the primitive to the scene
                    viewer.scene.primitives.add(boxEntityTop);
                    //}
                })
                .catch((error) => {
                    console.error("Failed to load the image:", error);
                });

            */

            // My original code to create the boxEntityTop before I was trying to fix the
            // flickering issue.
            /* 
            boxEntityTop = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstance,

                id: 'boxEntity',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap',
                          uniforms : {
                              image : fetchedImg,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                asynchronous: false,
            }));
            */
            
            // Add the other five primitives/sides to the scene
            boxEntityBottom = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceBot,

                id: 'boxEntityBot',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap2',
                          uniforms : {
                              image : textureImgBot,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                //asynchronous: false,
                asynchronous: true,
            }));
            boxEntityEdge1 = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceEdge1,

                id: 'boxEntityEdg1',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap3',
                          uniforms : {
                              image : textureImgEdge1,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                //asynchronous: false,
                asynchronous: true,
            }));
            boxEntityEdge2 = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceEdge2,

                id: 'boxEntityEdg2',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap4',
                          uniforms : {
                              image : textureImgEdge2,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                //asynchronous: false,
                asynchronous: true,
            }));
            boxEntityEdge3 = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceEdge3,

                id: 'boxEntityEdg3',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap5',
                          uniforms : {
                              image : textureImgEdge3,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                //asynchronous: false,
                asynchronous: true,
            }));
            boxEntityEdge4 = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceEdge4,

                id: 'boxEntityEdg4',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap6',
                          uniforms : {
                              image : textureImgEdge4,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                //asynchronous: false,
                asynchronous: true,
            }));
            
            viewer.scene.globe.depthTestAgainstTerrain = false;
            viewer.scene.globe.allowPicking = false;

        }

        function updateSlidersFromDropdown() {
            const coords = document.getElementById('data-file').value;
            if (coords) {
                const limits = coords.replace(/[()]/g, '').split(',');
                const minLonSlider = document.getElementById('minLonSlider');
                const maxLonSlider = document.getElementById('maxLonSlider');
                const minLatSlider = document.getElementById('minLatSlider');
                const maxLatSlider = document.getElementById('maxLatSlider');
                const minDepthSlider = document.getElementById('minDepthSlider');
                const maxDepthSlider = document.getElementById('maxDepthSlider');

                minLonSlider.min = parseFloat(limits[0]);
                minLonSlider.max = parseFloat(limits[1]);
                minLonSlider.value = parseFloat(limits[0]);
                document.getElementById('minLonValue').textContent = minLonSlider.value;

                maxLonSlider.min = parseFloat(limits[0]);
                maxLonSlider.max = parseFloat(limits[1]);
                maxLonSlider.value = parseFloat(limits[1]);
                document.getElementById('maxLonValue').textContent = maxLonSlider.value;

                minLatSlider.min = parseFloat(limits[2]);
                minLatSlider.max = parseFloat(limits[3]);
                minLatSlider.value = parseFloat(limits[2]);
                document.getElementById('minLatValue').textContent = minLatSlider.value;

                maxLatSlider.min = parseFloat(limits[2]);
                maxLatSlider.max = parseFloat(limits[3]);
                maxLatSlider.value = parseFloat(limits[3]);
                document.getElementById('maxLatValue').textContent = maxLatSlider.value;

                minDepthSlider.min = parseFloat(limits[4]);
                minDepthSlider.max = parseFloat(limits[5]);
                minDepthSlider.value = parseFloat(limits[4]);
                document.getElementById('minDepthValue').textContent = minDepthSlider.value;

                maxDepthSlider.min = parseFloat(limits[4]);
                maxDepthSlider.max = parseFloat(limits[5]);
                maxDepthSlider.value = parseFloat(limits[5]);
                document.getElementById('maxDepthValue').textContent = maxDepthSlider.value;
	        

                updateBoxOutline(parseFloat(minLatSlider.value), parseFloat(maxLatSlider.value), parseFloat(minLonSlider.value), parseFloat(maxLonSlider.value), parseFloat(minDepthSlider.value), parseFloat(maxDepthSlider.value), parseFloat(document.getElementById('alphaSlider').value));
            } else {
                if (boxEntityTop) {
                    viewer.scene.primitives.remove(boxEntityTop);
                    boxEntityTop = null;
                }
                if (boxEntityBottom) {
                    viewer.scene.primitives.remove(boxEntityBottom);
                    boxEntityBottom = null;
                }
                if (boxEntityEdge1) {
                    viewer.scene.primitives.remove(boxEntityEdge1);
                    boxEntityEdge1 = null;
                }
                if (boxEntityEdge2) {
                    viewer.scene.primitives.remove(boxEntityEdge2);
                    boxEntityEdge2 = null;
                }
                if (boxEntityEdge3) {
                    viewer.scene.primitives.remove(boxEntityEdge3);
                    boxEntityEdge3 = null;
                }
                if (boxEntityEdge4) {
                    viewer.scene.primitives.remove(boxEntityEdge4);
                    boxEntityEdge4 = null;
                }
            }
        }

        // Event listeners for the sliders
        document.getElementById('minLatSlider').addEventListener('input', function () {
            document.getElementById('minLatValue').textContent = this.value;
            updateBoxOutline(parseFloat(this.value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('maxLatSlider').addEventListener('input', function () {
            document.getElementById('maxLatValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(this.value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('minLonSlider').addEventListener('input', function () {
            document.getElementById('minLonValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(this.value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('maxLonSlider').addEventListener('input', function () {
            document.getElementById('maxLonValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(this.value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('minDepthSlider').addEventListener('input', function () {
            document.getElementById('minDepthValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(this.value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
        });

        document.getElementById('maxDepthSlider').addEventListener('input', function () {
            document.getElementById('maxDepthValue').textContent = this.value;
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(this.value), parseFloat(document.getElementById('alphaSlider').value));
        });
        document.getElementById('alphaSlider').addEventListener('input', function () {
            document.getElementById('alphaValue').textContent = this.value;
            // This line has a bug in it and should instead look like the next line of code
            //updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(this.value), parseFloat(document.getElementById('alphaSlider').value));
            updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(this.value));
        });

        document.getElementById('data-file').addEventListener('change', updateSlidersFromDropdown);
        // Update the data-vars dropdown options when the model selected from the data-file dropdown changes
        document.getElementById('data-file').addEventListener('change', loadVarDropdown);

        // Update the box outline when the selected variable in the data-vars dropdown changes
        document.getElementById('data-vars').addEventListener('change', function() {
            const minLat = parseFloat(document.getElementById('minLatSlider').value);
            const maxLat = parseFloat(document.getElementById('maxLatSlider').value);
            const minLon = parseFloat(document.getElementById('minLonSlider').value);
            const maxLon = parseFloat(document.getElementById('maxLonSlider').value);
            const minDepth = parseFloat(document.getElementById('minDepthSlider').value);
            const maxDepth = parseFloat(document.getElementById('maxDepthSlider').value);
            const alpha = parseFloat(document.getElementById('alphaSlider').value);

            // Call updateBoxOutline with the current slider values
            updateBoxOutline(minLat, maxLat, minLon, maxLon, minDepth, maxDepth, alpha);
        });

        // Load initial dropdown and update sliders
        loadDropdown();

        var points = [];
        var distanceDisplay = document.getElementById('distanceDisplay');
        var clearButton = document.getElementById('clearButton');

        function calculateDistance(point1, point2) {
            return Cesium.Cartesian3.distance(point1, point2);
        }

        function updateDistanceDisplay(distance) {
            distanceDisplay.textContent = 'Distance: ' + distance.toFixed(2) + ' meters';
        }


        function clearDistance() {
            points = [];
            distanceDisplay.textContent = '';
            viewer.entities.removeAll();
        }

        var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        handler.setInputAction(function (click) {
            var cartesian = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);
            if (cartesian) {
                if (document.getElementById('clearCheckbox').checked) {
                    points.push(cartesian);
                }
                if (points.length >= 2) {
                    var distance = calculateDistance(points[points.length - 2], points[points.length - 1]);
                    updateDistanceDisplay(distance);
                    viewer.entities.add({
                        polyline: {
                            positions: points,
                            width: 2,
                            material: Cesium.Color.TEAL
                        }
                    });
                }
            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        document.getElementById('clearCheckbox').addEventListener('change', function () {
            if (!this.checked) {
                clearDistance();
            }
        });

        document.getElementById('toggleGlobeCheckbox').addEventListener('change', function () {
            viewer.scene.globe.show = this.checked;
        });

        document.addEventListener('DOMContentLoaded', function () {
            var toggleSubductionCheckbox = document.getElementById('toggleSubductionCheckbox');
            var subductionDataSource;

            function handleSubductionData(checked) {
                if (checked) {
                    Cesium.GeoJsonDataSource.load(auxData[0], {
                        stroke: auxColor[0],
                        strokeWidth: auxLineWidth[0],
                        fill: auxColor[0].withAlpha(auxFillOpacity[0])
                    }).then(function (dataSource) {
                        subductionDataSource = dataSource;
                        viewer.dataSources.add(dataSource);
                    }).catch(function (error) {
                        console.error('Error loading GeoJSON:', error);
                    });
                } else {
                    if (viewer.dataSources.contains(subductionDataSource)) {
                        viewer.dataSources.remove(subductionDataSource);
                    }
                }
            }

            toggleSubductionCheckbox.addEventListener('change', function () {
                handleSubductionData(this.checked);
            });

            handleSubductionData(toggleSubductionCheckbox.checked);
        });
    </script>
</body>

</html>
