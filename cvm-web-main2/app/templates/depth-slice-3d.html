<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CesiumJS GeoJSON Example</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.116/Build/Cesium/Cesium.js"></script>
    <style>
        @import url(https://cesium.com/downloads/cesiumjs/releases/1.116/Build/Cesium/Widgets/widgets.css);

        .cesium-selection-wrapper {
            display: none !important;
        }

        #cesiumContainer {
            width: 100%;
            /* height: calc(85vh - 55px); */
            /* I changed the height of the Cesium container so that the 
            legend does not overlap it at the bottom. */
            height: calc(85vh - 100px);
            float: left;
            position: relative;
        }

        #cesiumTexture {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #distanceControl {
            position: absolute;
            bottom: 20px;
            left: 15px;
            z-index: 1;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }

        #distanceDisplay {
            margin-bottom: 5px;
        }

        #clearButton {
            margin-right: 10px;
        }

        #fileSelection {
            position: absolute;
            bottom: 100px;
            left: 10px;
            z-index: 1;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 50px;
        }

        #logoContainer {
            position: absolute;
            /* bottom: 110px; */
            bottom: 120px;
            right: 10px;
            z-index: 1;
        }

        #logoContainer img {
            width: 200px;
        }

        #legendContainer {
            width: auto;
            float: left;
            padding: 20px;
            position: absolute;
            /* bottom: 110px; */
            bottom: 120px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
        }
        
        /* 
        This is the original auxLegendContainer code. I changed it
        so that the auxLegendContainer has a flex display since the
        CVM Coverage legend item has a flex display and caused the
        other legend item to get pushed up and overlap with items above it.

        #auxLegendContainer {
            width: auto;
            float: left;
            padding: 20px;
            position: absolute;
            bottom: 60px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
        }
        */

        #auxLegendContainer {
            width: auto;
            float: left;
            padding: 20px;
            position: absolute;
            bottom: 60px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 30px;
        }

        .legendItem {
            margin-bottom: 10px;
            display: inline-block;
            margin-right: 20px;
        }

        .legendColor {
            width: 20px;
            height: 20px;
            display: inline-block;
            margin-right: 5px;
        }

        /* Defaults for the color bars (not including the labels associated with them) */ 
        .legendColorBar {
            width: 150px;
            height: 20px;
            display: inline-block;
            margin-right: 5px;
        }

        /* Defaults for the container that holds both the color bar and its minimum/maximum values */ 
        .colorBarValLabel {
            display: flex;
            justify-content: space-between;
            margin-top: 2px;
        }

        /* Defaults for the class that holds the minimum/maximum values for the color bars */ 
        .colorBarValues {
            font-size: 10px;
        }

        /* Defaults for the class that holds labels for the color bars (located on the right-hand side of the bar) */ 
        .colorBarLabel {
            margin-left: 5px;
        }

        .checkboxRow {
            display: flex;
            flex-wrap: wrap;
        }

        .checkboxRow label {
            margin-right: 10px;
        }

        #toggleButton,
        #controlContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            padding: 10px;
            background-color: #ffffff;
            border: 1px solid #cccccc;
            border-radius: 5px;
            cursor: pointer;
        }

        #controlContainer {
            background-color: rgba(255, 255, 255, 0.4);
            z-index: 1000;
        }

        #toggleGlobeContainer,
        #toggleSubductionInterface,
        #eqcontrols,
        #toggleTerrainOcclusion {
            margin-bottom: 10px;
        }

        #eqcontrols {
            background-color: transparent;
        }

        .sliderContainer {
            margin-bottom: 10px;
        }

        .sliderLabel {
            margin-right: 10px;
        }

        .button {
            background-color: #004F59;
            color: lightgray;
            width: 100%;
            border-radius: 15px;
            /* Adjust the value to make the corners more or less rounded */
        }
    </style>
</head>

<body>
    <!--script type="module" src="./depth-slice-3d.html"></script-->
    <div id="cesiumContainer"></div>
    <div id="controlContainer">
        <center><b>CFM 3D Viewer</b></center>
        <hr />
        <div id="toggleGlobeContainer">
            <label>
                <input type="checkbox" id="toggleGlobeCheckbox">Imagery layer
            </label>
        </div>
        <div id="toggleSubductionInterface">
            <label>
                <input type="checkbox" id="toggleSubductionCheckbox" checked> Cascadia Subduction Interface
            </label>
        </div>
        <div id="eqcontrols">
            <label><input type="checkbox" id="showEarthquakesCheckbox" checked> Earthquakes</label>
            <br>
            <label>Circle Size: <input type="range" id="circleSizeSlider" min="0" max="0.2" step="0.01"
                    value="0.04"></label>
        </div>
        <div id="toggleTerrainOcclusion">
            <label>
                <input type="checkbox" id="toggleTerrainOcclusionCheckbox" checked> Terrain Occlusion
            </label>
        </div>
        <!-- Slider controls for model boundaries -->
        <div>
            <hr style="border-top: 1px solid #0000FF" />
        </div>
        <form id="iframe-form">
            <div>
                <label for="data-file">CVM:</label>
                <select id="data-file" name="data_file"></select>
            </div>
            <div>&nbsp;</div>
            <!-- Dropdown for the variables associated with the selected data file -->
            <div>
                <label for="data-vars">Variable:</label>
                <select id="data-vars" name="data_vars">
                    <option value="vs">vs</option>
                    <option value="rho">rho</option>
                </select>
            </div>
            <div>&nbsp;</div>
            <!-- Dropdown for the slider animation to determine which axis to animate -->
            <div>
                <label for="anim-axis">Animation Axis:</label>
                <select id="anim-axis" name="anim_axis">
                    <option value="none">none</option>
                    <option value="latitude">latitude</option>
                    <option value="longitude">longitude</option>
                    <option value="depth">depth</option>
                    <option value="diagonal">diagonal</option>
                </select>
            </div>
            <!-- Slider to change the time for the slice animation -->
            <div class="sliderContainer">
                <label class="sliderLabel">Animation Time (sec): <input type="range" id="animLength" min="1.0" max="80.0"
                        step="0.1" value="30"></label>
                <span id="animLengthValue">30</span>
            </div>
            <!-- Button to start the slice animation -->
            <button type="button" class="button" id="animButton">Animate Slices</button>
            <!-- Slider to change the minimum latitude of the bounding box -->
            <div class="sliderContainer">
                <label class="sliderLabel">Min Latitude: <input type="range" id="minLatSlider" min="47" max="50.9"
                        step="0.1" value="47"></label>
                <span id="minLatValue">47</span>
            </div>
            <!-- Slider to change the maximum latitude of the bounding box -->
            <div class="sliderContainer">
                <label class="sliderLabel">Max Latitude: <input type="range" id="maxLatSlider" min="47" max="50.9"
                        step="0.1" value="50.9"></label>
                <span id="maxLatValue">50.9</span>
            </div>
            <!-- Slider to change the minimum longitude of the bounding box -->
            <div class="sliderContainer">
                <label class="sliderLabel">Min Longitude: <input type="range" id="minLonSlider" min="-126" max="-121.1"
                        step="0.1" value="-126"></label>
                <span id="minLonValue">-126</span>
            </div>
            <!-- Slider to change the maximum longitude of the bounding box -->
            <div class="sliderContainer">
                <label class="sliderLabel">Max Longitude: <input type="range" id="maxLonSlider" min="-126" max="-121.1"
                        step="0.1" value="-121.1"></label>
                <span id="maxLonValue">-121.1</span>
            </div>
            <!-- Slider to change the minimum depth of the bounding box -->
            <div class="sliderContainer">
                <label class="sliderLabel">Depth (km): <input type="range" id="minDepthSlider" min="0" max="93" step="1"
                        value="0"></label>
                <span id="minDepthValue">0</span>
            </div>

            <!-- Slider to change the maximum depth of the bounding box -->
            <!-- Change the maxDepthSlider so it appears on the webpage which allows me to add the other sides of the bounding box to the globe -->
            <!--div class="sliderContainer" style="display: none;"-->
            <div class="sliderContainer">
                <label class="sliderLabel">Max Depth (km): <input type="range" id="maxDepthSlider" min="0" max="93"
                        step="1" value="93"></label>
                <span id="maxDepthValue">93</span>
            </div>

            <!-- I tried implementing a diagonal slice toggle and slider, but I have not been able to get it working yet -->
            <div id="toggleDiagSlice">
                <label>
                    <input type="checkbox" id="toggleDiagSliceCheckbox">Diagonal Slice
                </label>
            </div>
            <!-- Slider to change what percentage along the diagonal axis going from the bottom left corner to the top right corner (relative to the default view of the globe) of the bounding box to get the diagonal slice -->
            <div class="sliderContainer" id="diagSliderWrapper">
                <label class="sliderLabel">Diagonal Slice (%): <input type="range" id="diagSlider" min="0" max="100" step="1"
                        value="0"></label>
                <span id="diagValue">0</span>
            </div>
            <!-- Slider to change the transparency of the bounding box slices (lower values are more transparent) -->
            <div class="sliderContainer">
                <label class="sliderLabel">Alpha: <input type="range" id="alphaSlider" min="0" max="1" step="0.1"
                        value="0.3"></label>
                <span id="alphaValue">0.3</span>
            </div>
            <button type="button" class="button" id="sync-to-parent">Sync to Form</button>
        </form>

    </div>

    <div id="mapControls">
        <div id="logoContainer">
            <img src="/static/images/crescent_logos_horizontal_transparent.png" alt="Logo">
        </div>
        <div id="legendContainer"></div>
        <div id="auxLegendContainer"></div>
        <div id="distanceControl">
            <label><input type="checkbox" id="clearCheckbox"> Measure Distance</label>
            <div id="distanceDisplay">Click distances will appear here</div>
        </div>
    </div>

    <script>

        Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmZDQzMzIyOS1lZDFlLTRhNTgtYTE1Yy04YzNkNWQ2ZmI4OTIiLCJpZCI6MjAxODU5LCJpYXQiOjE3MTA0MDQ5MDd9._E6MFZMMjbxpzC4qYYROP1ldtV1MJn0f56W5woAtboc";
        const apiKey = "AAPKafd67a0544f04817b08c2f65379b76c8pz3w8RSH_npDJjf9phbqEJ2kbD8QnfX-lzVlJ7dUi_3pQjwWS-vNFeXT6jacicfJ";

        var viewer = new Cesium.Viewer('cesiumContainer', {
            depthPlaneEllipsoidOffset: 10000,
            nearToFarRatio: 1e6,
            farToNearRatio: 1e-6,
            sceneMode: Cesium.SceneMode.SCENE3D,
            scene3DOnly: true,
            enableCollisionDetection: false,
            baseLayer: Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3813)),
            globe: new Cesium.Globe(Cesium.Ellipsoid.WGS84, {
                minimumZoomDistance: 0.0
            })
        });

        // Function to read and clear an item from localStorage
        function readAndClearLocalStorageItem(key) {
            // Step 1: Read the item from localStorage
            const item = localStorage.getItem(key);

            // Step 2: Remove the item from localStorage
            localStorage.removeItem(key);

            // Step 3: Return the parsed item, or null if it doesn't exist
            return item !== null ? JSON.parse(item) : null;
        }

        // Usage example to get selectedLines
        const selectedLines = readAndClearLocalStorageItem('selectedLines') || [];
        if (selectedLines.length != 0) {
            console.log('Selected lines:', selectedLines);
        }

        viewer.scene.globe.frontFaceAlphaByDistance = new Cesium.NearFarScalar(50.0, 0.0, 100.0, 1.0);
        viewer.scene.globe.show = false;
        viewer.scene.skyAtmosphere.show = false;
        viewer.scene.fog.enabled = false;
        viewer.scene.globe.showGroundAtmosphere = false;
        viewer.scene.globe.depthTestAgainstTerrain = true;

        const toggleTerrainOcclusionCheckbox = document.getElementById('toggleTerrainOcclusionCheckbox');
        toggleTerrainOcclusionCheckbox.addEventListener('change', function () {
            viewer.scene.globe.depthTestAgainstTerrain = toggleTerrainOcclusionCheckbox.checked;
        });

        viewer.scene.setTerrain(new Cesium.Terrain(Cesium.CesiumTerrainProvider.fromIonAssetId(2426648)));
        const scene = viewer.scene;
        const globe = scene.globe;
        const camera = scene.camera;

        scene.fog.enabled = false;
        globe.showGroundAtmosphere = false;
        globe.enableLighting = true;

        scene.light = new Cesium.DirectionalLight({
            direction: new Cesium.Cartesian3(1, 0, 0),
        });

        const scratchNormal = new Cesium.Cartesian3();
        scene.preRender.addEventListener(function (scene, time) {
            const surfaceNormal = globe.ellipsoid.geodeticSurfaceNormal(camera.positionWC, scratchNormal);
            const negativeNormal = Cesium.Cartesian3.negate(surfaceNormal, surfaceNormal);
            scene.light.direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.add(negativeNormal, camera.rightWC, surfaceNormal), scene.light.direction);
        });

        globe.maximumScreenSpaceError = 1.0;
        viewer.scene.backgroundColor = new Cesium.Color(0.0, 0.0, 0.0, 0.0);
        viewer.camera.flyTo({
            destination: Cesium.Rectangle.fromDegrees(-130.0, 39.0, -116.0, 52.0)
        });

        viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(-132.76, 39.84, 718005.890),
            orientation: {
                heading: Cesium.Math.toRadians(48.65),
                pitch: Cesium.Math.toRadians(-36.05),
                roll: 0.3
            }
        });

        viewer.scene.globe.baseColor = Cesium.Color.TRANSPARENT;
        viewer.animation.container.style.visibility = 'hidden';
        viewer.timeline.container.style.visibility = 'hidden';

        var dataSources = [];
        const auxData = ["https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/cascadia_subduction_interface_temp.geojson"];
        const auxLabel = ["Cascadia Subduction Interface"];
        const auxColor = [Cesium.Color.GREEN];
        const auxFillOpacity = [0.5];
        const auxLineWidth = [4];

        var data = ['/static/boundary_geojson/us-states.json', '/static/boundary_geojson/georef-canada-province-public.geojson', 'https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/crescent_cfm_crustal_traces.geojson', 'https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/crescent_cfm_crustal_3d.geojson'];
        var label = ['US', 'Canada', 'CRESCENT Cascadia Fault Traces', 'CRESCENT Cascadia Fault Surfaces', 'Earthquakes M > 4'];
        const geojson_files = ['https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/crescent_cfm_crustal_traces.geojson', 'https://raw.githubusercontent.com/cascadiaquakes/crescent-cfm/main/crescent_cfm_files/crescent_cfm_crustal_3d.geojson']
        const dataColor = [Cesium.Color.GRAY, Cesium.Color.DIMGRAY, Cesium.Color.CRIMSON, Cesium.Color.DARKMAGENTA, Cesium.Color.YELLOW];
        const fillOpacity = [0.0, 0.0, 0.5, 0.5];
        const lineWidth = [2, 0.5, 2, 2];

        // Really need only one variable, but my attempts at merging them was drawing extra diagonal line.
        var boxEntityTop;
        var boxEntityBottom;
        var boxEntityEdge1;
        var boxEntityEdge2;
        var boxEntityEdge3;
        var boxEntityEdge4;
        var diagEntity;

        async function loadDropdown() {
            try {
                const response = await fetch('/models_drop_down');
                if (response.ok) {
                    const dropdownHTML = await response.text();
                    document.getElementById('data-file').innerHTML = dropdownHTML;
                } else {
                    console.error('Failed to load dropdown:', response.statusText);
                    document.getElementById('data-file').textContent = 'Failed to load dropdown.';
                }
            } catch (error) {
                console.error('Error fetching dropdown:', error);
                document.getElementById('data-file').textContent = 'Error loading dropdown.';
            }

        }

        //select an option from a <select> menu based on the optionâ€™s text
        function selectOptionByText(text) {
            const selectElement = document.getElementById('data-file');
            const options = selectElement.options;

            for (let i = 0; i < options.length; i++) {
                if (options[i].text === text) {
                    selectElement.selectedIndex = i;
                    optionFound = true;

                    // Trigger the change event
                    updateSlidersFromDropdown();

                    return;
                }
            }

            alert('Option not found: ' + text);
        }



        // Send message to the parent indicating ready to sync.
        document.addEventListener('DOMContentLoaded', function () {
            const iframeForm = document.getElementById('iframe-form');

            // Function to send the current form data to the parent
            function syncToParent() {
                const formData = new FormData(iframeForm);
                const data = {};
                formData.forEach((value, key) => {
                    data[key] = value;
                });

                window.parent.postMessage({
                    type: 'syncFromIframe',
                    data
                }, window.location.origin);
            }

            // Function to handle messages from the parent
            window.addEventListener('message', function (event) {
                if (event.origin !== window.location.origin) {
                    return; // Ignore messages from other origins for security
                }
                if (event.data.type === 'syncFromParent') {
                    function copyIframeFormValues() {
                        const data = event.data.data;

                        // The model selection update.
                        selectOptionByText(data['data-file'])

                        // Sliders update.
                        document.getElementById('minLonSlider').value = data['start-lng'];
                        document.getElementById('maxLonSlider').value = data['end-lng'];
                        document.getElementById('minLatSlider').value = data['start-lat'];
                        document.getElementById('maxLatSlider').value = data['end-lat'];
                        document.getElementById('minDepthSlider').value = data['start-depth'];
                        

                        // Slider labels update.
                        document.getElementById('minLonValue').textContent = data['start-lng'];
                        document.getElementById('maxLonValue').textContent = data['end-lng'];
                        document.getElementById('minLatValue').textContent = data['start-lat'];
                        document.getElementById('maxLatValue').textContent = data['end-lat'];
                        document.getElementById('minDepthValue').textContent = data['start-depth'];

                        // Update the outline box.
                        updateBoxOutline(parseFloat(minLatSlider.value), parseFloat(maxLatSlider.value), parseFloat(minLonSlider.value), parseFloat(maxLonSlider.value), parseFloat(minDepthSlider.value), parseFloat(maxDepthSlider.value), parseFloat(document.getElementById('alphaSlider').value));


                    }
                    copyIframeFormValues();

                }

                if (event.data.type === 'requestSyncToParent') {
                    syncToParent();
                }
            });

            // Sync to parent button
            document.getElementById('sync-to-parent').addEventListener('click', syncToParent);
        });



        // Call loadDropdown when the page has finished loading
        document.addEventListener('DOMContentLoaded', loadDropdown);


        for (var i = 0; i < data.length; i++) {
            (function (index) {
                const dataSource = Cesium.GeoJsonDataSource.load(data[index], {
                    label: label[index],
                    stroke: dataColor[index],
                    fill: dataColor[index].withAlpha(fillOpacity[index]),
                    strokeWidth: lineWidth[index],
                    markerSymbol: '?'
                });
                dataSource.then(function (dataSource) {
                    var entitiesToRemove = [];
                    dataSource.entities.values.forEach(function (entity) {
                        var ok = true;
                        // Display all if selectedLines is empty.
                        if (selectedLines.length != 0) {
                            if (geojson_files.includes(data[index]) && !selectedLines.includes(String(entity.properties.id))) {
                                ok = false;
                                entitiesToRemove.push(entity);
                            }
                        }
                        if (ok) {
                            if (Cesium.defined(entity.polygon)) {
                                var coordinates = entity.polygon.hierarchy.getValue().positions;
                                coordinates.forEach(function (coordinate) {
                                    Cesium.Cartographic.fromCartesian(coordinate);
                                });
                            } else if (Cesium.defined(entity.polyline)) {
                                var positions = entity.polyline.positions.getValue();
                                positions.forEach(function (position) {
                                    Cesium.Cartographic.fromCartesian(position);
                                });
                            }
                            var description = '';
                            var properties = entity.properties;
                            for (var propertyName in properties) {
                                if (properties.hasOwnProperty(propertyName) && typeof properties[propertyName] !== 'function') {
                                    var propNameWithoutUnderscore = propertyName.replace(/^_/, '');
                                    description += propNameWithoutUnderscore + ': ' + properties[propertyName] + '<br />';
                                }
                            }
                            entity.description = description;
                        }
                    });

                    entitiesToRemove.forEach(function (entity) {
                        dataSource.entities.remove(entity);
                    });

                    dataSources.push(dataSource);
                    viewer.dataSources.add(dataSource);
                });

                if (i == 0) {
                    async function loadEarthquakeData(url) {
                        try {
                            const dataSource = await Cesium.GeoJsonDataSource.load(url, {
                                clampToGround: false
                            });
                            earthquakeDataSource = dataSource;
                            viewer.dataSources.add(dataSource);
                            updateEarthquakeVisibility();

                            const entities = dataSource.entities.values;
                            const circleSizeSlider = document.getElementById('circleSizeSlider');
                            entities.forEach(function (entity) {
                                entity.billboard = undefined;
                                if (entity.position) {
                                    let coordinates = Cesium.Cartographic.fromCartesian(entity.position.getValue(Cesium.JulianDate.now()));
                                    let depthInMeters = coordinates.height * 1000;
                                    entity.position = new Cesium.ConstantPositionProperty(Cesium.Cartesian3.fromDegrees(
                                        Cesium.Math.toDegrees(coordinates.longitude),
                                        Cesium.Math.toDegrees(coordinates.latitude),
                                        -depthInMeters
                                    ));
                                }
                                entity.point = new Cesium.PointGraphics({
                                    pixelSize: calculateMarkerSize(circleSizeSlider.value, entity.properties.mag.getValue()),
                                    color: Cesium.Color.YELLOW
                                });
                            });
                        } catch (error) {
                            console.log('Error loading earthquake data:', error);
                        }
                    }

                    loadEarthquakeData('https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=1970-01-01&minmagnitude=4&minlatitude=30&maxlatitude=50&minlongitude=-125&maxlongitude=-100');

                    function updateEarthquakeVisibility() {
                        if (earthquakeDataSource) {
                            var showEarthquakes = document.getElementById('showEarthquakesCheckbox').checked;
                            earthquakeDataSource.show = showEarthquakes;
                        }
                    }

                    document.getElementById('showEarthquakesCheckbox').addEventListener('change', updateEarthquakeVisibility);

                    function calculateMarkerSize(baseSize, magnitude) {
                        const scaleFactor = 3;
                        return baseSize * Math.pow(magnitude, scaleFactor);
                    }

                    document.getElementById('circleSizeSlider').addEventListener('input', function () {
                        if (earthquakeDataSource) {
                            var entities = earthquakeDataSource.entities.values;
                            entities.forEach(function (entity) {
                                entity.point = new Cesium.PointGraphics({
                                    color: Cesium.Color.YELLOW,
                                    pixelSize: calculateMarkerSize(circleSizeSlider.value, entity.properties.mag)
                                });
                            });
                        }
                    });
                }
            })(i);
        }

        // Create the legend for the fault traces, fault surfaces, earthquake locations and country bountries
        var legendContainer = document.getElementById('legendContainer');
        label.forEach(function (labelText, i) {
            var legendItem = document.createElement('div');
            legendItem.classList.add('legendItem');

            var legendColor = document.createElement('div');
            legendColor.classList.add('legendColor');
            legendColor.style.backgroundColor = dataColor[i].toCssColorString();

            var legendLabel = document.createElement('span');
            legendLabel.textContent = labelText;

            legendItem.appendChild(legendColor);
            legendItem.appendChild(legendLabel);
            legendContainer.appendChild(legendItem);
        });

        // Create the legend for the Cascadia Subduction Interface
        var auxLegendContainer = document.getElementById('auxLegendContainer');

        auxColor.forEach(function (color, i) {
            var legendItem = document.createElement('div');
            legendItem.classList.add('legendItem');

            var legendColor = document.createElement('div');
            legendColor.classList.add('legendColor');
            legendColor.style.backgroundColor = color.toCssColorString();

            var legendLabel = document.createElement('span');
            legendLabel.textContent = auxLabel[i];

            legendItem.appendChild(legendColor);
            legendItem.appendChild(legendLabel);
            auxLegendContainer.appendChild(legendItem);
        });
        // Create the legend for the bounding box slices from the CVM
        var cvmLegendItem = document.createElement('div');
        cvmLegendItem.classList.add('legendItem');
        // Change the display to flex so the label is to the right of the color bar
        cvmLegendItem.style.display = "flex";

        var legendColorTest = document.createElement('div');
        legendColorTest.classList.add('legendColorBar');
        legendColorTest.style.background = "linear-gradient( 90deg, rgb(0, 0, 255) 0%, rgb(0, 255, 255) 25%, rgb(0, 255, 0) 50%, rgb(255, 255, 0) 75%, rgb(255, 0, 0) 100%)";

        // Create a container that holds both the color bar and its minimum/maximum values for the CVM data set
        var colorBarAndVals = document.createElement('div');
        colorBarAndVals.style.width = "150px";

        colorBarAndVals.appendChild(legendColorTest);

        var colorBarVals = document.createElement('div');
        colorBarVals.classList.add('colorBarValLabel');

        var minColorBarVal = document.createElement('span');
        minColorBarVal.classList.add('colorBarValues');
        minColorBarVal.textContent = "0.0"; // Default value

        var maxColorBarVal = document.createElement('span');
        maxColorBarVal.classList.add('colorBarValues');
        maxColorBarVal.textContent = "5.0"; // Default value

        colorBarVals.appendChild(minColorBarVal);
        colorBarVals.appendChild(maxColorBarVal);
        colorBarAndVals.appendChild(colorBarVals);

        var cvmLegendLabel = document.createElement('span');
        cvmLegendLabel.classList.add('colorBarLabel');
        cvmLegendLabel.textContent = "CVM Coverage";

        cvmLegendItem.appendChild(colorBarAndVals);
        cvmLegendItem.appendChild(cvmLegendLabel);
        auxLegendContainer.appendChild(cvmLegendItem);
        
        // Update the options given in the data-file and data-vars dropdown menus
        // when the webpage is first loaded.
        async function loadDropdown() {
            // Try to update the data-file dropdown options based on what is in the 
            // http://0.0.0.0:8000/models_drop_down_coverage page
            try {
                const response = await fetch('/models_drop_down_coverage');
                if (response.ok) {
                    const dropdownHTML = await response.text();
                    document.getElementById('data-file').innerHTML = dropdownHTML;
                    // Initialize sliders based on the first dropdown option
                    updateSlidersFromDropdown();
                } else {
                    console.error('Failed to load dropdown:', response.statusText);
                    document.getElementById('data-file').textContent = 'Failed to load dropdown.';
                }
            } catch (error) {
                console.error('Error fetching dropdown:', error);
                document.getElementById('data-file').textContent = 'Error loading dropdown.';
            }
            // Try to update the data-vars dropdown options based on what is in the 
            // http://0.0.0.0:8000/vis/models_drop_down page and which file was selected
            // in the data-file dropdown menu
            try {
                const response_var = await fetch('/vis/models_drop_down');
                if (response_var.ok) {
                    const dropdownvarHTML = await response_var.text();
                    var selected_data_set = document.getElementById('data-file').options[document.getElementById('data-file').selectedIndex].text;
                    const dropdownvarHTML_list = dropdownvarHTML.split("<option ");

                    const dropdown_models = [];
                    const dropdown_variables = [];

                    // Isolate the model names and their associated variables from the models
                    // listed in http://0.0.0.0:8000/vis/models_drop_down and input each of them into an array
                    for (var i = 0; i < dropdownvarHTML_list.length; i++) {
                        if (dropdownvarHTML_list[i].length > 0) {
                            const model = dropdownvarHTML_list[i].split(">")[1].replace("</option", "");
                            const model_name = model.split(" ")[0];
                            const model_vars = model.split(" ")[1];
                            dropdown_models.push(model_name);
                            dropdown_variables.push(model_vars);  
                        }
                    }

                    // Get the array of variables that are associated with the model selected in the data-file dropdown
                    let selected_data_set_vars = ['vs'];  // Set the default array of variables to be vs

                    for (var i = 0; i < dropdown_models.length; i++) {
                        if (dropdown_models[i] == selected_data_set) {
                            selected_data_set_vars = dropdown_variables[i].replace("(", "").replace(")", "").split(",");
                        }
                    }

                    // Add the HTML information back to the variable options
                    for (var i = 0; i < selected_data_set_vars.length; i++) {
                         selected_data_set_vars[i] = "<option value=\"" + selected_data_set_vars[i] + "\">" + selected_data_set_vars[i] + "</option>";
                    }
                    // Update the data-vars dropdown options        
                    document.getElementById('data-vars').innerHTML = selected_data_set_vars.join(" ");
                    // Initialize sliders based on the first dropdown option
                    updateSlidersFromDropdown();
                } else {
                    console.error('Failed to load variable dropdown:', response_var.statusText);
                    document.getElementById('data-vars').textContent = 'Failed to load variable dropdown.';
                }
            } catch (error) {
                console.error('Error fetching variable dropdown:', error);
                document.getElementById('data-vars').textContent = 'Error loading variable dropdown.';
            }
            // Update the anim-axis dropdown options based on what is selected
            // in the data-file dropdown menu
            var selected_data_set = document.getElementById('data-file').options[document.getElementById('data-file').selectedIndex].text;
            var diag_slider = document.getElementById('diagSliderWrapper');
            var diag_val = document.getElementById('diagValue');
            var diag_checkbox = document.getElementById('toggleDiagSlice');
            toggleDiagOptions(selected_data_set, diag_checkbox, diag_slider, diag_val);
        }
        // Update the options given in the data-vars dropdown menu after the webpage has finished
        // loading for the first time (this function is called every time the selected model in the
        // data-file dropdown menu changes).
        async function loadVarDropdown() {
            // Try to update the data-vars dropdown options based on what is in the 
            // http://0.0.0.0:8000/vis/models_drop_down page and which file was selected
            // in the data-file dropdown menu
            try {
                const response_var = await fetch('/vis/models_drop_down');
                if (response_var.ok) {
                    const dropdownvarHTML = await response_var.text();
                    var selected_data_set = document.getElementById('data-file').options[document.getElementById('data-file').selectedIndex].text;
                    const dropdownvarHTML_list = dropdownvarHTML.split("<option ");

                    const dropdown_models = [];
                    const dropdown_variables = [];

                    // Isolate the model names and their associated variables from the models
                    // listed in http://0.0.0.0:8000/vis/models_drop_down and input each of them into an array
                    for (var i = 0; i < dropdownvarHTML_list.length; i++) {
                        if (dropdownvarHTML_list[i].length > 0) {
                            const model = dropdownvarHTML_list[i].split(">")[1].replace("</option", "");
                            const model_name = model.split(" ")[0];
                            const model_vars = model.split(" ")[1];
                            dropdown_models.push(model_name);
                            dropdown_variables.push(model_vars);  
                        }
                    }

                    // Get the array of variables that are associated with the model selected in the data-file dropdown
                    let selected_data_set_vars = ['vs'];

                    for (var i = 0; i < dropdown_models.length; i++) {
                        if (dropdown_models[i] == selected_data_set) {
                            selected_data_set_vars = dropdown_variables[i].replace("(", "").replace(")", "").split(",");
                        }
                    }
                            

                    // Add the HTML information back to the variable options
                    for (var i = 0; i < selected_data_set_vars.length; i++) {
                         selected_data_set_vars[i] = "<option value=\"" + selected_data_set_vars[i] + "\">" + selected_data_set_vars[i] + "</option>";
                    }

                    // Update the data-vars dropdown options        
                    document.getElementById('data-vars').innerHTML = selected_data_set_vars.join(" ");
                    // Initialize sliders based on the first dropdown option
                    updateSlidersFromDropdown();
                } else {
                    console.error('Failed to load variable dropdown:', response_var.statusText);
                    document.getElementById('data-vars').textContent = 'Failed to load variable dropdown.';
                }
            } catch (error) {
                console.error('Error fetching variable dropdown:', error);
                document.getElementById('data-vars').textContent = 'Error loading variable dropdown.';
            }
            // Update the anim-axis dropdown options based on what is selected
            // in the data-file dropdown menu
            var selected_data_set = document.getElementById('data-file').options[document.getElementById('data-file').selectedIndex].text;
            var diag_slider = document.getElementById('diagSliderWrapper');
            var diag_val = document.getElementById('diagValue');
            var diag_checkbox = document.getElementById('toggleDiagSlice');
            toggleDiagOptions(selected_data_set, diag_checkbox, diag_slider, diag_val);
        }

        // Toggle the visibility of the diagonal slice options depending on which data set is 
        // selected in the data-file dropdown menu. The inputs for the function are the data set
        // selected in the CVM (data-file) dropdown menu, whether the Diagonal Slice checkbox 
        // (toggleDiagSlice) is checked or not, the Diagonal Slice slider container (diagSliderWrapper) 
        // and the value selected from the Diagonal Slice slider (diagValue).
        function toggleDiagOptions(data_set, diag_checkbox, diag_slider, diag_val) {
            // I currently only have diagonal slices for the SVI_EQTOMO_Savard2018 data set. Update this if statement once more diagonal slices are added for the other data sets.
            if (data_set == 'SVI_EQTOMO_Savard2018') {
                document.getElementById('anim-axis').innerHTML = "<option value=\"none\">none</option> <option value=\"latitude\">latitude</option> <option value=\"longitude\">longitude</option> <option value=\"depth\">depth</option> <option value=\"diagonal\">diagonal</option>";
                diag_checkbox.style.display = 'flex';
                diag_slider.style.display = 'block';
            } else {
                document.getElementById('anim-axis').innerHTML = "<option value=\"none\">none</option> <option value=\"latitude\">latitude</option> <option value=\"longitude\">longitude</option> <option value=\"depth\">depth</option>";
                // Change the visibility so that the diagonal checkbox and slider are invisible
                diag_checkbox.style.display = 'none';
                diag_slider.style.display = 'none';
                // Make sure the diagonal slice checkbox is unchecked
                document.getElementById('toggleDiagSliceCheckbox').checked = false;
            }
        }

        // Call loadDropdown when the page has finished loading
        document.addEventListener('DOMContentLoaded', loadDropdown);

        // Function that updates the dimensions of each side of the bounding box and the slice images shown. It takes
        // as input the values selected from the Min Latitude, Max Latitude, Min Longitude, Max Longitude, Depth, Max Depth
        // and Alpha sliders.
        async function updateBoxOutline(minLat, maxLat, minLon, maxLon, minDepth, maxDepth, alpha) {
            // Clear all items in localStorage for the current origin
            localStorage.clear();

            // Clear all items in sessionStorage for the current origin (session-specific)
            sessionStorage.clear();
            // fetch the json file with the information about the group of slice images
            var data_set = document.getElementById('data-file').options[document.getElementById('data-file').selectedIndex].text;
            var data_var = document.getElementById('data-vars').options[document.getElementById('data-vars').selectedIndex].text;
            var jsonFile = '../static/json/Cascadia_ANT+RF_Delph2018_slices.json';

            if (data_set == 'Cascadia_ANT+RF_Delph2018') {
                jsonFile = '../static/json/Cascadia_ANT+RF_Delph2018_slices.json';
            } else if (data_set == 'SVI_EQTOMO_Savard2018') {
                jsonFile = '../static/json/SVI_EQTOMO_Savard2018_slices.json';
            } else {  // I plan to add the casc1.6_velmdl slices to the webpage later
                console.log("The data set selected is not available");
            }
            // Set default values for all of the form fields in the json file
            var numImgs = 0;
            var dirName = '';
            var imgStem = '';
            var minPer = 0;
            var lonNumImgs = 0;
            var lonDirName = '';
            var lonImgStem = '';
            var lonMinPer = 0;
            var latNumImgs = 0;
            var latDirName = '';
            var latImgStem = '';
            var latMinPer = 0;
            var vsMin = 0;
            var vsMax = 0;
            var vsUnits = '';
            var rhoMin = 0;
            var rhoMax = 0;
            var rhoUnits = '';
            var jsonData = {};

            // Try to read the json file
            try {
                // Add a timestamp or a version number to the URL to make sure the newest json file is fetched (comment these two lines out when I am not debugging the code to make the webpage run faster)
                //const cacheBuster = new Date().getTime(); 
                //const response = await fetch(jsonFile + "?v=" + cacheBuster);
                const response = await fetch(jsonFile);
                if (!response.ok) {
                    throw new Error('Failed to load JSON: ${response.statusText}');
                }

                jsonData = await response.json();

            } catch (e) {
                console.error("Error processing JSON data:", e);
                // If JSON data is critical and corrupted, prevent further rendering
                return;
            }


            // Assuming the JSON structure matches your form fields' ids
            for (const [key, value] of Object.entries(jsonData)) {
                if (key === "num_images") {
                    numImgs = value;
                }
                if (key === "dir_name") {
                    dirName = value;
                }
                if (key === "img_stem") {
                    imgStem = value;
                }
                if (key === "min_per") {
                    minPer = value;
                }
                if (key === "lon_axis_num_images") {
                    lonNumImgs = value;
                }
                if (key === "lon_axis_dir_name") {
                    lonDirName = value;
                }
                if (key === "lon_axis_img_stem") {
                    lonImgStem = value;
                }
                if (key === "lon_axis_min_per") {
                    lonMinPer = value;
                }
                if (key === "lat_axis_num_images") {
                    latNumImgs = value;
                }
                if (key === "lat_axis_dir_name") {
                    latDirName = value;
                }
                if (key === "lat_axis_img_stem") {
                    latImgStem = value;
                }
                if (key === "lat_axis_min_per") {
                    latMinPer = value;
                }
                if (key === "vs_min_val") {
                    vsMin = value;
                }
                if (key === "vs_max_val") {
                    vsMax = value;
                }
                if (key === "vs_units") {
                    vsUnits = value;
                }
                if (key === "rho_min_val") {
                    rhoMin = value;
                }
                if (key === "rho_max_val") {
                    rhoMax = value;
                }
                if (key === "rho_units") {
                    rhoUnits = value;
                }
            }

            // Update the minimum and maximum values of the CVM Coverage legend
            var colorBarMinMaxVals = document.querySelectorAll(".colorBarValues");
            
            if (!colorBarMinMaxVals) {
                console.error("Color bar legend min max values not found");
                return;
            }

            if (data_var === "vs") {
                colorBarMinMaxVals[0].textContent = vsMin;
                colorBarMinMaxVals[1].textContent = vsMax;
            }
            if (data_var === "rho") {
                colorBarMinMaxVals[0].textContent = rhoMin;
                colorBarMinMaxVals[1].textContent = rhoMax;
            }

            // Update the units of the CVM Coverage legend
            var cvmLabel = document.querySelector(".colorBarLabel"); // Only one color bar/color bar label is in the legend

            if (!cvmLabel) {
                console.error("Color bar legend label element not found");
                return;
            }

            var newCVMLabel = "CVM Coverage";
    
            // Add the units to the end of the label depending on the variable selected
            if (data_var === "vs") {
                newCVMLabel = newCVMLabel + " (" + vsUnits + ")";
                cvmLabel.textContent = newCVMLabel;
            }
            if (data_var === "rho") {
                newCVMLabel = newCVMLabel + " (" + rhoUnits + ")";
                cvmLabel.textContent = newCVMLabel;
            }

            // Coordinates for the four corners.
            var positions = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, minDepth * -1000,  // Longitude, Latitude, Height
                maxLon, minLat, minDepth * -1000,
                maxLon, maxLat, minDepth * -1000,
                minLon, maxLat, minDepth * -1000,
            ]);


            // Coordinates for the four corners for the bottom side of the bounding box.
            var positionsBot = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, maxDepth * -1000,  // Longitude, Latitude, Height
                maxLon, minLat, maxDepth * -1000,
                maxLon, maxLat, maxDepth * -1000,
                minLon, maxLat, maxDepth * -1000,
            ]);


            // Coordinates for the four corners for the edge 1 of the bounding box.
            var positionsEdge1 = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, minDepth * -1000,  // Longitude, Latitude, Height
                minLon, minLat, maxDepth * -1000,
                minLon, maxLat, maxDepth * -1000,
                minLon, maxLat, minDepth * -1000,
            ]);


            // Coordinates for the four corners for the edge 2 of the bounding box.
            var positionsEdge2 = Cesium.Cartesian3.fromDegreesArrayHeights([
                maxLon, minLat, minDepth * -1000,  // Longitude, Latitude, Height
                maxLon, minLat, maxDepth * -1000,
                maxLon, maxLat, maxDepth * -1000,
                maxLon, maxLat, minDepth * -1000,
            ]);
            

            // Coordinates for the four corners for the edge 3 of the bounding box.
            var positionsEdge3 = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, minLat, minDepth * -1000,  // Longitude, Latitude, Height
                minLon, minLat, maxDepth * -1000,
                maxLon, minLat, maxDepth * -1000,
                maxLon, minLat, minDepth * -1000,
            ]);


            // Coordinates for the four corners for the edge 4 of the bounding box.
            var positionsEdge4 = Cesium.Cartesian3.fromDegreesArrayHeights([
                minLon, maxLat, minDepth * -1000,  // Longitude, Latitude, Height
                minLon, maxLat, maxDepth * -1000,
                maxLon, maxLat, maxDepth * -1000,
                maxLon, maxLat, minDepth * -1000,
            ]);

            // Remove any previous primitives that were added to the scene from a previous call to updateBoxOutline
            if (boxEntityTop !== null) {
                viewer.scene.primitives.remove(boxEntityTop);
            }
            if (boxEntityBottom !== null) {
                viewer.scene.primitives.remove(boxEntityBottom);
            }
            if (boxEntityEdge1 !== null) {
                viewer.scene.primitives.remove(boxEntityEdge1);
            }
            if (boxEntityEdge2 !== null) {
                viewer.scene.primitives.remove(boxEntityEdge2);
            }
            if (boxEntityEdge3 !== null) {
                viewer.scene.primitives.remove(boxEntityEdge3);
            }
            if (boxEntityEdge4 !== null) {
                viewer.scene.primitives.remove(boxEntityEdge4);
            }


            const minDepthSliderTest = document.getElementById('minDepthSlider');
            const maxDepthSliderTest = document.getElementById('maxDepthSlider');
            const minLonSliderTest = document.getElementById('minLonSlider');
            const maxLonSliderTest = document.getElementById('maxLonSlider');
            const minLatSliderTest = document.getElementById('minLatSlider');
            const maxLatSliderTest = document.getElementById('maxLatSlider');
            const alphaSliderVal = document.getElementById('alphaSlider');

            
            var minDepthTest = minDepthSliderTest.min;
            var maxDepthTest = maxDepthSliderTest.max;
            var minLonTest = minLonSliderTest.min;
            var maxLonTest = maxLonSliderTest.max;
            var minLatTest = minLatSliderTest.min;
            var maxLatTest = maxLatSliderTest.max;

            var depthDiff = minDepthSliderTest.value - minDepthTest;
            var depthRange = (maxDepthTest - minDepthTest) + 1;

            // Function that takes in the stem of the image name, the minimum percentage slice
            // in VisIt where the slice contains data (which corresponds to the lowest number 
            // at the end of the file name in the sequence of y-axis slices), the current value
            // of the depth slider, the minimum and maximum values of the depth slider, the 
            // number of y-axis slice images and the variable selected in the data-vars dropdown
            // to return part of the file path and image name for the image that will be used as the
            // texture for the bounding box side
            function getImageName(stem, minPer, depth, minDepth, maxDepth, numImages, varName) {

	        var depthDiff = depth - minDepth;
                var depthRange = (maxDepth - minDepth) + 1;
            
                let depthImgsStep;
                if (numImages <= 1) { // If only one image or zero images, step is irrelevant, assume index 0/minPer
                    depthImgsStep = 1;
                } else {
                    depthImgsStep = (depthRange * 1.0) / (numImages);
                    if (depthImgsStep === 0) { // If range is 0, but multiple images, step still 0, avoid division by zero
                        depthImgsStep = 1; // Assume only first image relevant if no range
                    }
                }

                var depthImgsIndx = minPer + Math.round(depthDiff/depthImgsStep);

                // Clamp the index to valid bounds based on numImages and minPer
                const maxValidIndex = minPer + numImages - 1;
        
                if (depthImgsIndx < minPer) {
                    depthImgsIndx = minPer;
                } else if (depthImgsIndx > maxValidIndex) {
                    depthImgsIndx = maxValidIndex;
                }

                console.assert(Number.isInteger(depthImgsIndx) && depthImgsIndx >= 0, '[getImageName: ' + varName + '] Final index is not a valid non-negative integer!');

                const texturePath = varName + '/' + varName + '_' + stem + depthImgsIndx + '.png';
                return texturePath;

            }
            // Function that takes in the stem of the image name, the minimum percentage slice
            // in VisIt where the slice contains data (which corresponds to the lowest number 
            // at the end of the file name in the sequence of x-axis or z-axis slices), the current value
            // of the lat/lon slider, the minimum and maximum values of the lat/lon slider, the 
            // number of x-axis or z-axis slice images and the variable selected in the data-vars dropdown
            // to return part of the file path and image name for the image that will be used as the
            // texture for the bounding box side
            function getLonLatImageName(stem, minPer, value, minVal, maxVal, numImages, varName) {

	        var valDiff = value - minVal;
                var valRange = (maxVal - minVal);
            
                let valImgsStep;
                if (numImages <= 1) { // If only one image or zero images, step is irrelevant, assume index 0/minPer
                    valImgsStep = 1;
                } else {
                    valImgsStep = (valRange * 1.0) / (numImages);
                    if (valImgsStep === 0) { // If range is 0, but multiple images, step still 0, avoid division by zero
                        valImgsStep = 1; // Assume only first image relevant if no range
                    }
                }

                var valImgsIndx = minPer + Math.round(valDiff/valImgsStep);

                // Clamp the index to valid bounds based on numImages and minPer
                const maxValidIndex = minPer + numImages - 1;
        
                if (valImgsIndx < minPer) {
                    valImgsIndx = minPer;
                } else if (valImgsIndx > maxValidIndex) {
                    valImgsIndx = maxValidIndex;
                }

                console.assert(Number.isInteger(valImgsIndx) && valImgsIndx >= 0, '[getLonLatImageName: ' + varName + '] Final index is not a valid non-negative integer!');

                const texturePath = varName + '/' + varName + '_' + stem + valImgsIndx + '.png';
                return texturePath;

            }

            minDepthTest = parseFloat(minDepthTest);
            maxDepthTest = parseFloat(maxDepthTest);
            minLonTest = parseFloat(minLonTest);
            maxLonTest = parseFloat(maxLonTest);
            minLatTest = parseFloat(minLatTest);
            maxLatTest = parseFloat(maxLatTest);

            // Get the file paths and slice image names for the images that will be used as textures for all six sides of the bounding box
            var textureImg = dirName.concat(getImageName(imgStem, minPer, parseFloat(minDepthSliderTest.value), minDepthTest, maxDepthTest, numImgs, data_var));
            
            var textureImgBot = dirName.concat(getImageName(imgStem, minPer, parseFloat(maxDepthSliderTest.value), minDepthTest, maxDepthTest, numImgs, data_var));

            var textureImgEdge1 = lonDirName.concat(getLonLatImageName(lonImgStem, lonMinPer, parseFloat(minLonSliderTest.value), minLonTest, maxLonTest, lonNumImgs, data_var));

            var textureImgEdge2 = lonDirName.concat(getLonLatImageName(lonImgStem, lonMinPer, parseFloat(maxLonSliderTest.value), minLonTest, maxLonTest, lonNumImgs, data_var));

            var textureImgEdge3 = latDirName.concat(getLonLatImageName(latImgStem, latMinPer, parseFloat(minLatSliderTest.value), minLatTest, maxLatTest, latNumImgs, data_var));

            var textureImgEdge4 = latDirName.concat(getLonLatImageName(latImgStem, latMinPer, parseFloat(maxLatSliderTest.value), minLatTest, maxLatTest, latNumImgs, data_var));


            var numPositions = 4;
            var pos = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          pos[i * 3] = positions[i].x;
                          pos[i * 3 + 1] = positions[i].y;
                          pos[i * 3 + 2] = positions[i].z;
                      }

            var posBot = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posBot[i * 3] = positionsBot[i].x;
                          posBot[i * 3 + 1] = positionsBot[i].y;
                          posBot[i * 3 + 2] = positionsBot[i].z;
                      }

            var posEdge1 = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posEdge1[i * 3] = positionsEdge1[i].x;
                          posEdge1[i * 3 + 1] = positionsEdge1[i].y;
                          posEdge1[i * 3 + 2] = positionsEdge1[i].z;
                      }
            var posEdge2 = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posEdge2[i * 3] = positionsEdge2[i].x;
                          posEdge2[i * 3 + 1] = positionsEdge2[i].y;
                          posEdge2[i * 3 + 2] = positionsEdge2[i].z;
                      }
            var posEdge3 = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posEdge3[i * 3] = positionsEdge3[i].x;
                          posEdge3[i * 3 + 1] = positionsEdge3[i].y;
                          posEdge3[i * 3 + 2] = positionsEdge3[i].z;
                      }
            var posEdge4 = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          posEdge4[i * 3] = positionsEdge4[i].x;
                          posEdge4[i * 3 + 1] = positionsEdge4[i].y;
                          posEdge4[i * 3 + 2] = positionsEdge4[i].z;
                      }

            // Calculate the UV coordinates to determine how the images should be mapped to the sides of the bounding box
            var min_x_ratio = (minLon - minLonSliderTest.min)/(maxLonSliderTest.max - minLonSliderTest.min);
            var max_x_ratio = (maxLon - maxLonSliderTest.min)/(maxLonSliderTest.max - minLonSliderTest.min);
            var min_y_ratio = (minLat - minLatSliderTest.min)/(maxLatSliderTest.max - minLatSliderTest.min);
            var max_y_ratio = (maxLat - maxLatSliderTest.min)/(maxLatSliderTest.max - minLatSliderTest.min);
            var uvs = [min_x_ratio, min_y_ratio, max_x_ratio, min_y_ratio, max_x_ratio, max_y_ratio, min_x_ratio, max_y_ratio];
            var indexs = new Uint16Array([0, 1, 2, 2, 3, 0]);
            var min_z_ratio = (minDepth - minDepthSliderTest.min)/(maxDepthSliderTest.max - minDepthSliderTest.min);
            var max_z_ratio = (maxDepth - maxDepthSliderTest.min)/(maxDepthSliderTest.max - minDepthSliderTest.min);
            var uvsEdge1 = [min_z_ratio, min_y_ratio, max_z_ratio, min_y_ratio, max_z_ratio, max_y_ratio, min_z_ratio, max_y_ratio];

            var uvsEdge3 = [min_z_ratio, min_x_ratio, max_z_ratio, min_x_ratio, max_z_ratio, max_x_ratio, min_z_ratio, max_x_ratio];
        
            // Create the geometry for each of the six primitives (one for each bounding box side)
            var geometry = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: pos
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvs
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(pos)
            });

            var geometryBot = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posBot
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvs
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posBot)
            });


            var geometryEdge1 = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posEdge1
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvsEdge1
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posEdge1)
            });
            
            var geometryEdge2 = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posEdge2
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvsEdge1
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posEdge2)
            });

            var geometryEdge3 = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posEdge3
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvsEdge3
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posEdge3)
            });

            var geometryEdge4 = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: posEdge4
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvsEdge3
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(posEdge4)
            });

            // Create the geometry instances for each bounding box side
            var myInstance = new Cesium.GeometryInstance({
                geometry: geometry,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceBot = new Cesium.GeometryInstance({
                geometry: geometryBot,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceEdge1 = new Cesium.GeometryInstance({
                geometry: geometryEdge1,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceEdge2 = new Cesium.GeometryInstance({
                geometry: geometryEdge2,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceEdge3 = new Cesium.GeometryInstance({
                geometry: geometryEdge3,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            var myInstanceEdge4 = new Cesium.GeometryInstance({
                geometry: geometryEdge4,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
   
            try {
                // Create the Cesium material for the mimimum depth slice bounding box side
                var fetchedImg;
                topMaterial = new Cesium.Material({
                  fabric : {
                      type : 'MyCustomMap',
                      uniforms : {
                          image : '',
                          color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                      },
                      components : {
                          emission : 'texture(image, materialInput.st).rgb',
                          alpha : 'texture(image, materialInput.st).a * color.a'
                      }
                    },
                    translucent: true
                });

                // Add the minimum depth slice primitive/side to the scene
                boxEntityTop = viewer.scene.primitives.add(new Cesium.Primitive({
                    geometryInstances: myInstance,

                    id: 'boxEntity',

                    appearance: new Cesium.MaterialAppearance({
                        material : topMaterial,
                    }),
                    //asynchronous: false,
                    asynchronous: true,
                }));

                if (boxEntityTop) {
                    boxEntityTop.show = false; // Hide the primitive temporarily
                }
                viewer.allowDataSourcesToSuspendAnimation = true;
                // I tried to use a promise to try to force it to load the image before displaying it
                new Promise((resolve, reject) => {
                Cesium.Resource.fetchImage({url: textureImg}).then((image) => {
                    topMaterial.uniforms.image = image;
                    viewer.scene.requestRender();
                    // Show the primitive again after it's fully updated
                    boxEntityTop.show = true;
                    resolve('Texture loaded and applied');
                })
                .catch((error) => {
                    console.error('Error loading texture:', error);
                    reject(error); // Propagate error if loading fails
                });
                });
            } catch (error) {
                // Handle errors
                console.log(`There was an error while creating the top slice primitive. ${error}`);
            }

            // I tried to use Cesium.Resource.fetchImage before creating the boxEntityTop to see
            // if that would load the image before it tried to render it.
            /*

            console.log("Start");
            setTimeout(() => {
                console.log("Executed after 1 seconds");
            }, 1000); // 1000 milliseconds = 1 seconds

            console.log("End"); // This will log before the setTimeout callback
            var fetchedImg;
            Cesium.Resource.fetchImage({url: textureImg}).then(function(image) {
                //texture.copyFrom(image);
                fetchedImg = image;
                boxEntityTop = viewer.scene.primitives.add(new Cesium.Primitive({
                    geometryInstances: myInstance,

                    id: 'boxEntity',

                    appearance: new Cesium.MaterialAppearance({
                        material : new Cesium.Material({
                          fabric : {
                              type : 'MyCustomMap',
                              uniforms : {
                                  image : fetchedImg,
                                  color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                              },
                              components : {
                                  emission : 'texture(image, materialInput.st).rgb',
                                  alpha : 'texture(image, materialInput.st).a * color.a'
                              }
                            },
                            translucent: true
                        }),
                    }),
                    asynchronous: false,
                }));
            }).catch(function(error) {
                console.log(`There was an error while creating the top slice primitive. ${error}`);
            });
            */
            // I tried to use Cesium.Resource.fetchImage before creating the material for the boxEntityTop to see
            // if that would load the image before it tried to render it.
            /*
            // Use Cesium.Resource.fetchImage to load the image
            Cesium.Resource.fetchImage(textureImg)
                .then((loadedImage) => {
                    // Create a custom material with the loaded image
                    /*
                    const material = new Cesium.Material({
                        fabric: {
                            type: "Image",
                            uniforms: {
                                image: loadedImage
                            }
                        }
                    });
                    */
                    /*
                    topMaterial = new Cesium.Material({
                        fabric : {
                            type : 'MyCustomMap',
                            uniforms : {
                                image : loadedImage,
                                color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                            },
                            components : {
                                emission : 'texture(image, materialInput.st).rgb',
                                alpha : 'texture(image, materialInput.st).a * color.a'
                            }
                         },
                         translucent: true
                    });

                    if (boxEntityTop !== null) {
                        viewer.scene.primitives.remove(boxEntityTop);
                        //boxEntityTop.appearance.material.uniforms.image = loadedImage;
                    } //else {
                    */
                    // Create a primitive with a custom geometry
                    /*
                    const primitive = new Cesium.Primitive({
                        geometryInstances: new Cesium.GeometryInstance({
                            geometry: new Cesium.RectangleGeometry({
                                rectangle: Cesium.Rectangle.fromDegrees(-100.0, 30.0, -90.0, 40.0),
                                vertexFormat: Cesium.MaterialAppearance.VERTEX_FORMAT
                            })
                        }),
                        appearance: new Cesium.MaterialAppearance({
                            material: material,
                        })
                    });
                    */
                    /*
                    boxEntityTop = new Cesium.Primitive({
                        geometryInstances: myInstance,

                        id: 'boxEntity',

                        appearance: new Cesium.MaterialAppearance({
                            material : topMaterial,
                        }),
                        asynchronous: false,
                    });

                    //boxEntityTop.appearance.material.uniforms.image = loadedImage;

                    // Add the primitive to the scene
                    viewer.scene.primitives.add(boxEntityTop);
                    //}
                })
                .catch((error) => {
                    console.error("Failed to load the image:", error);
                });

            */

            // My original code to create the boxEntityTop before I was trying to fix the
            // flickering issue.
            /* 
            boxEntityTop = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstance,

                id: 'boxEntity',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap',
                          uniforms : {
                              image : fetchedImg,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                asynchronous: false,
            }));
            */
            
            // Add the other five primitives/sides to the scene
            boxEntityBottom = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceBot,

                id: 'boxEntityBot',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap2',
                          uniforms : {
                              image : textureImgBot,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                asynchronous: true,
            }));
            boxEntityEdge1 = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceEdge1,

                id: 'boxEntityEdg1',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap3',
                          uniforms : {
                              image : textureImgEdge1,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                asynchronous: true,
            }));
            boxEntityEdge2 = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceEdge2,

                id: 'boxEntityEdg2',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap4',
                          uniforms : {
                              image : textureImgEdge2,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                asynchronous: true,
            }));
            boxEntityEdge3 = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceEdge3,

                id: 'boxEntityEdg3',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap5',
                          uniforms : {
                              image : textureImgEdge3,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                asynchronous: true,
            }));
            boxEntityEdge4 = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstanceEdge4,

                id: 'boxEntityEdg4',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap6',
                          uniforms : {
                              image : textureImgEdge4,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                asynchronous: true,
            }));
            
            viewer.scene.globe.depthTestAgainstTerrain = false;
            viewer.scene.globe.allowPicking = false;

        }

        function updateSlidersFromDropdown() {
            const coords = document.getElementById('data-file').value;
            if (coords) {
                const limits = coords.replace(/[()]/g, '').split(',');
                const minLonSlider = document.getElementById('minLonSlider');
                const maxLonSlider = document.getElementById('maxLonSlider');
                const minLatSlider = document.getElementById('minLatSlider');
                const maxLatSlider = document.getElementById('maxLatSlider');
                const minDepthSlider = document.getElementById('minDepthSlider');
                const maxDepthSlider = document.getElementById('maxDepthSlider');

                // Update the minimum and maximum values as well as the default selected value 
                // for the different sliders based on the CVM data set chosen from the data-file
                // dropdown
                minLonSlider.min = parseFloat(limits[0]);
                minLonSlider.max = parseFloat(limits[1]);
                minLonSlider.value = parseFloat(limits[0]);
                document.getElementById('minLonValue').textContent = minLonSlider.value;

                maxLonSlider.min = parseFloat(limits[0]);
                maxLonSlider.max = parseFloat(limits[1]);
                maxLonSlider.value = parseFloat(limits[1]);
                document.getElementById('maxLonValue').textContent = maxLonSlider.value;

                minLatSlider.min = parseFloat(limits[2]);
                minLatSlider.max = parseFloat(limits[3]);
                minLatSlider.value = parseFloat(limits[2]);
                document.getElementById('minLatValue').textContent = minLatSlider.value;

                maxLatSlider.min = parseFloat(limits[2]);
                maxLatSlider.max = parseFloat(limits[3]);
                maxLatSlider.value = parseFloat(limits[3]);
                document.getElementById('maxLatValue').textContent = maxLatSlider.value;

                minDepthSlider.min = parseFloat(limits[4]);
                minDepthSlider.max = parseFloat(limits[5]);
                minDepthSlider.value = parseFloat(limits[4]);
                document.getElementById('minDepthValue').textContent = minDepthSlider.value;

                maxDepthSlider.min = parseFloat(limits[4]);
                maxDepthSlider.max = parseFloat(limits[5]);
                maxDepthSlider.value = parseFloat(limits[5]);
                document.getElementById('maxDepthValue').textContent = maxDepthSlider.value;
	        
                // Update the slice images of the bounding box/diagonal slice to match the new data set
                if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                    updateBoxOutline(parseFloat(minLatSlider.value), parseFloat(maxLatSlider.value), parseFloat(minLonSlider.value), parseFloat(maxLonSlider.value), parseFloat(minDepthSlider.value), parseFloat(maxDepthSlider.value), parseFloat(document.getElementById('alphaSlider').value));
                } else {
                    updateDiagonal(document.getElementById('toggleDiagSliceCheckbox').checked, parseFloat(document.getElementById('diagSlider').value), parseFloat(document.getElementById('alphaSlider').value));
                }
            } else {
                if (boxEntityTop) {
                    viewer.scene.primitives.remove(boxEntityTop);
                    boxEntityTop = null;
                }
                if (boxEntityBottom) {
                    viewer.scene.primitives.remove(boxEntityBottom);
                    boxEntityBottom = null;
                }
                if (boxEntityEdge1) {
                    viewer.scene.primitives.remove(boxEntityEdge1);
                    boxEntityEdge1 = null;
                }
                if (boxEntityEdge2) {
                    viewer.scene.primitives.remove(boxEntityEdge2);
                    boxEntityEdge2 = null;
                }
                if (boxEntityEdge3) {
                    viewer.scene.primitives.remove(boxEntityEdge3);
                    boxEntityEdge3 = null;
                }
                if (boxEntityEdge4) {
                    viewer.scene.primitives.remove(boxEntityEdge4);
                    boxEntityEdge4 = null;
                }
            }
        }

        // Utility function to create a delay where ms is the delay in milliseconds
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
 
        // This function runs an animation of all of the slice images along one of the axes (latitude, longitude, depth or
        // along a diagonal through the data). It takes as input the current values selected with the Min Latitude, Max
        // Latitude, Min Longitude, Max Longitude, Depth, Max Depth, Diagonal Slice and Alpha sliders as well as the axis
        // chosen in the Animation Axis dropdown, the value selected with the Animation Time slider and the number of slices/frames
        // to run through in the animation.
        async function runAnimation(minLat, maxLat, minLon, maxLon, minDepth, maxDepth, diag, alpha, axis, time, numFrames) {
            const timeStepSize = (time/numFrames) * 1000; // The time to pause between each slice is given in milliseconds
            
            // Remove any previous diagonal slice primitive that was added to the scene
            if (diagEntity !== null) {
                viewer.scene.primitives.remove(diagEntity);
            }

            // If the animation axis is set to anything other than "none," then run the animation for the
            // selected axis
            if (axis == "latitude") {
                const latRange = maxLat - minLat;
                const latStepSize = latRange/numFrames;

                let newMinLat = minLat;

                for (let i = 0; i < numFrames; i++) {
                    newMinLat = newMinLat + latStepSize;
                    document.getElementById('minLatValue').textContent = newMinLat.toFixed(2);
                    document.getElementById('minLatSlider').value = newMinLat;
                    // Call updateBoxOutline with the current slider values
                    updateBoxOutline(newMinLat, maxLat, minLon, maxLon, minDepth, maxDepth, alpha);

                    await delay(timeStepSize);
                }
            }
            if (axis == "longitude") {
                const lonRange = maxLon - minLon;
                const lonStepSize = lonRange/numFrames;

                let newMinLon = minLon;

                for (let i = 0; i < numFrames; i++) {
                    newMinLon = newMinLon + lonStepSize;
                    document.getElementById('minLonValue').textContent = newMinLon.toFixed(2);
                    document.getElementById('minLonSlider').value = newMinLon;
                    // Call updateBoxOutline with the current slider values
                    updateBoxOutline(minLat, maxLat, newMinLon, maxLon, minDepth, maxDepth, alpha);

                    await delay(timeStepSize);
                }
            }
            if (axis == "depth") {
                const depthRange = maxDepth - minDepth;
                const depthStepSize = depthRange/numFrames;

                let newMinDepth = minDepth;

                for (let i = 0; i < numFrames; i++) {
                    newMinDepth = newMinDepth + depthStepSize;
                    document.getElementById('minDepthValue').textContent = newMinDepth.toFixed(2);
                    document.getElementById('minDepthSlider').value = newMinDepth;
                    // Call updateBoxOutline with the current slider values
                    updateBoxOutline(minLat, maxLat, minLon, maxLon, newMinDepth, maxDepth, alpha);

                    await delay(timeStepSize);
                }
            }
            if (axis == "diagonal") {
                const maxDiag = parseFloat(document.getElementById('diagSlider').max);
                const minDiag = parseFloat(document.getElementById('diagSlider').min);
                const diagRange = maxDiag - minDiag;
                const diagStepSize = diagRange/numFrames;

                let newCurDiag = minDiag;

                for (let i = 0; i < numFrames; i++) {
                    newCurDiag = newCurDiag + diagStepSize;
                    document.getElementById('diagValue').textContent = newCurDiag.toFixed(2);
                    document.getElementById('diagSlider').value = newCurDiag;
                    // Call updateDiagonal with the current slider values
                    updateDiagonal(true, newCurDiag, alpha);

                    await delay(timeStepSize);
                }
            }
            // Call updateBoxOutline or updateDiagonal with the current slider values and set the slider values back to their original positions
            if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                updateBoxOutline(minLat, maxLat, minLon, maxLon, minDepth, maxDepth, alpha);
            } else {
                updateDiagonal(document.getElementById('toggleDiagSliceCheckbox').checked, diag, alpha);
            }

            document.getElementById('minLatValue').textContent = minLat;
            document.getElementById('minLatSlider').value = minLat;
            document.getElementById('minLonValue').textContent = minLon;
            document.getElementById('minLonSlider').value = minLon;
            document.getElementById('minDepthValue').textContent = minDepth;
            document.getElementById('minDepthSlider').value = minDepth;
            document.getElementById('diagValue').textContent = diag;
            document.getElementById('diagSlider').value = diag;
            

        }
        // Function that updates the dimensions and slice images shown for the diagonal slice.
        // It takes as input whether the Diagonal Slice checkbox is checked or not, the value
        // selected with the Diagonal Slice slider and the value selected with the Alpha slider.
        async function updateDiagonal(diagToggle, diag, alpha) {
            // Clear all items in localStorage for the current origin
            localStorage.clear();

            // Clear all items in sessionStorage for the current origin (session-specific)
            sessionStorage.clear();
            // fetch the json file with the information about the group of slice images
            var data_set = document.getElementById('data-file').options[document.getElementById('data-file').selectedIndex].text;
            var data_var = document.getElementById('data-vars').options[document.getElementById('data-vars').selectedIndex].text;
            var jsonFile = '../static/json/Cascadia_ANT+RF_Delph2018_slices.json';

            if (data_set == 'Cascadia_ANT+RF_Delph2018') {
                jsonFile = '../static/json/Cascadia_ANT+RF_Delph2018_slices.json';
            } else if (data_set == 'SVI_EQTOMO_Savard2018') {
                jsonFile = '../static/json/SVI_EQTOMO_Savard2018_slices.json';
            } else {  // I plan to add the casc1.6_velmdl slices to the webpage later
                console.log("The data set selected is not available");
            }
            var diagNumImgs = 0;
            var diagDirName = '';
            var diagImgStem = '';
            var diagMinPer = 0;
            var jsonData = {};

            // Try to read the json file
            try {
                const response = await fetch(jsonFile);
                if (!response.ok) {
                    throw new Error('Failed to load JSON: ${response.statusText}');
                }
                jsonData = await response.json();

            } catch (e) {
                console.error("Error processing JSON data:", e);
                // If JSON data is critical and corrupted, prevent further rendering
                return;
            }


            // Assuming the JSON structure matches your form fields' ids
            for (const [key, value] of Object.entries(jsonData)) {
                if (key === "diag_num_images") {
                    diagNumImgs = value;
                }
                if (key === "diag_dir_name") {
                    diagDirName = value;
                }
                if (key === "diag_img_stem") {
                    diagImgStem = value;
                }
                if (key === "diag_min_per") {
                    diagMinPer = value;
                }
            }

            // Function that takes in the stem of the image name, the minimum percentage slice
            // in VisIt where the slice contains data (which corresponds to the lowest number 
            // at the end of the file name in the sequence of x-axis or z-axis slices), the current value
            // of the lat/lon slider, the minimum and maximum values of the lat/lon slider, the 
            // number of x-axis or z-axis slice images and the variable selected in the data-vars dropdown
            // to return part of the file path and image name for the image that will be used as the
            // texture for the bounding box side
            function getImageName(stem, minPer, value, minVal, maxVal, numImages, varName) {

	        var valDiff = value - minVal;
                var valRange = (maxVal - minVal);
            
                let valImgsStep;
                if (numImages <= 1) { // If only one image or zero images, step is irrelevant, assume index 0/minPer
                    valImgsStep = 1;
                } else {
                    valImgsStep = (valRange * 1.0) / (numImages);
                    if (valImgsStep === 0) { // If range is 0, but multiple images, step still 0, avoid division by zero
                        valImgsStep = 1; // Assume only first image relevant if no range
                    }
                }

                var valImgsIndx = minPer + Math.round(valDiff/valImgsStep);

                // Clamp the index to valid bounds based on numImages and minPer
                const maxValidIndex = minPer + numImages - 1;
        
                if (valImgsIndx < minPer) {
                    valImgsIndx = minPer;
                } else if (valImgsIndx > maxValidIndex) {
                    valImgsIndx = maxValidIndex;
                }

                console.assert(Number.isInteger(valImgsIndx) && valImgsIndx >= 0, '[getImageName: ' + varName + '] Final index is not a valid non-negative integer!');

                const texturePath = varName + '/' + varName + '_' + stem + valImgsIndx + '.png';
                return texturePath;

            }
            if (boxEntityTop) {
                viewer.scene.primitives.remove(boxEntityTop);
                boxEntityTop = null;
            }
            if (boxEntityBottom) {
                viewer.scene.primitives.remove(boxEntityBottom);
                boxEntityBottom = null;
            }
            if (boxEntityEdge1) {
                viewer.scene.primitives.remove(boxEntityEdge1);
                boxEntityEdge1 = null;
            }
            if (boxEntityEdge2) {
                viewer.scene.primitives.remove(boxEntityEdge2);
                boxEntityEdge2 = null;
            }
            if (boxEntityEdge3) {
                viewer.scene.primitives.remove(boxEntityEdge3);
                boxEntityEdge3 = null;
            }
            if (boxEntityEdge4) {
                viewer.scene.primitives.remove(boxEntityEdge4);
                boxEntityEdge4 = null;
            }
            // Remove any previous diagonal slice primitive that was added to the scene from a previous call
            if (diagEntity !== null) {
                viewer.scene.primitives.remove(diagEntity);
            }
            const minDepthSliderTest = document.getElementById('minDepthSlider');
            const maxDepthSliderTest = document.getElementById('maxDepthSlider');
            const minLonSliderTest = document.getElementById('minLonSlider');
            const maxLonSliderTest = document.getElementById('maxLonSlider');
            const minLatSliderTest = document.getElementById('minLatSlider');
            const maxLatSliderTest = document.getElementById('maxLatSlider');
            const alphaSliderVal = document.getElementById('alphaSlider');

            var minDepthTest = minDepthSliderTest.min;
            var maxDepthTest = maxDepthSliderTest.max;
            var minLonTest = minLonSliderTest.min;
            var maxLonTest = maxLonSliderTest.max;
            var minLatTest = minLatSliderTest.min;
            var maxLatTest = maxLatSliderTest.max;

            var latRange = maxLatTest - minLatTest;
            var lonRange = maxLonTest - minLonTest;
            var diagPer = diag/100;

            const minLat = parseFloat(minLatTest);
            const maxLat = parseFloat(maxLatTest);
            const minLon = parseFloat(minLonTest);
            const maxLon = parseFloat(maxLonTest);
            const minDepth = parseFloat(minDepthTest);
            const maxDepth = parseFloat(maxDepthTest);

            if (diag > 50) {
                // Coordinates for the four corners for the diagonal slice.
                var positionsDiag = Cesium.Cartesian3.fromDegreesArrayHeights([
                    minLon + (lonRange * (2 * (diagPer - 0.5))), minLat, minDepth * -1000,  // Longitude, Latitude, Height
                    minLon + (lonRange * (2 * (diagPer - 0.5))), minLat, maxDepth * -1000,
                    maxLon, maxLat - (latRange * (2 * (diagPer - 0.5))), maxDepth * -1000,
                    maxLon, maxLat - (latRange * (2 * (diagPer - 0.5))), minDepth * -1000,
                ]);
            } else {
                // Coordinates for the four corners for the diagonal slice.
                var positionsDiag = Cesium.Cartesian3.fromDegreesArrayHeights([
                    minLon, maxLat - (latRange * diagPer * 2), minDepth * -1000,  // Longitude, Latitude, Height
                    minLon, maxLat - (latRange * diagPer * 2), maxDepth * -1000,
                    minLon + (lonRange * diagPer * 2), maxLat, maxDepth * -1000,
                    minLon + (lonRange * diagPer * 2), maxLat, minDepth * -1000,
                ]);
            }
            // Get the file path and slice image name for the diagonal image that will be used as a texture for the diagonal slice
            var textureImg = diagDirName.concat(getImageName(diagImgStem, diagMinPer, diag, parseFloat(document.getElementById('diagSlider').min), parseFloat(document.getElementById('diagSlider').max), diagNumImgs, data_var));

            var numPositions = 4;
            var pos = new Float64Array(numPositions * 3);
                      for (var i = 0; i < numPositions; ++i) {
                          pos[i * 3] = positionsDiag[i].x;
                          pos[i * 3 + 1] = positionsDiag[i].y;
                          pos[i * 3 + 2] = positionsDiag[i].z;
                      }
            
            // Calculate the UV coordinates to determine how the images should be mapped to the diagonal slice
            var min_y_ratio = (minLat - minLatSliderTest.min)/(maxLatSliderTest.max - minLatSliderTest.min);
            var max_y_ratio = (maxLat - maxLatSliderTest.min)/(maxLatSliderTest.max - minLatSliderTest.min);
            var indexs = new Uint16Array([0, 1, 2, 2, 3, 0]);
            var min_z_ratio = (minDepth - minDepthSliderTest.min)/(maxDepthSliderTest.max - minDepthSliderTest.min);
            var max_z_ratio = (maxDepth - maxDepthSliderTest.min)/(maxDepthSliderTest.max - minDepthSliderTest.min);
            var uvsEdge1 = [min_z_ratio, min_y_ratio, max_z_ratio, min_y_ratio, max_z_ratio, max_y_ratio, min_z_ratio, max_y_ratio];

            // Create the geometry for the diagonal slice primitive
            var geometry = new Cesium.Geometry({
              attributes: {
                  position: new Cesium.GeometryAttribute({
                      componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                      componentsPerAttribute: 3,
                      values: pos
                  }),
                  st: new Cesium.GeometryAttribute({
                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                    componentsPerAttribute: 2,
                    values: uvsEdge1
                  })
              },
              indices : indexs,
              primitiveType: Cesium.PrimitiveType.TRIANGLES,
              boundingSphere: Cesium.BoundingSphere.fromVertices(pos)
           });
            // Create the geometry instance for the diagonal slice
            var myInstance = new Cesium.GeometryInstance({
                geometry: geometry,
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.WHITE)
                }
            });
            diagEntity = viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: myInstance,

                id: 'diagEntity',

                appearance: new Cesium.MaterialAppearance({
                    material : new Cesium.Material({
                      fabric : {
                          type : 'MyCustomMap3',
                          uniforms : {
                              image : textureImg,
                              color : new Cesium.Color(1.0, 0.0, 0.0, alphaSliderVal.value)
                          },
                          components : {
                              emission : 'texture(image, materialInput.st).rgb',
                              alpha : 'texture(image, materialInput.st).a * color.a'
                          }
                        },
                        translucent: true
                    }),
                }),
                asynchronous: true,
            }));
        }
        // Event listeners for the sliders
        document.getElementById('minLatSlider').addEventListener('change', function () {
            document.getElementById('minLatValue').textContent = this.value;
            if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                updateBoxOutline(parseFloat(this.value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
            }
        });

        document.getElementById('maxLatSlider').addEventListener('change', function () {
            document.getElementById('maxLatValue').textContent = this.value;
            if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(this.value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
            }
        });

        document.getElementById('minLonSlider').addEventListener('change', function () {
            document.getElementById('minLonValue').textContent = this.value;
            if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(this.value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
            }
        });

        document.getElementById('maxLonSlider').addEventListener('change', function () {
            document.getElementById('maxLonValue').textContent = this.value;
            if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(this.value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
            }
        });

        document.getElementById('minDepthSlider').addEventListener('change', function () {
            document.getElementById('minDepthValue').textContent = this.value;
            if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(this.value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(document.getElementById('alphaSlider').value));
            }
        });

        document.getElementById('maxDepthSlider').addEventListener('change', function () {
            document.getElementById('maxDepthValue').textContent = this.value;
            if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(this.value), parseFloat(document.getElementById('alphaSlider').value));
            }
        });
        document.getElementById('alphaSlider').addEventListener('input', function () {
            document.getElementById('alphaValue').textContent = this.value;
            // This line has a bug in it and should instead look like the next line of code
            //updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(this.value), parseFloat(document.getElementById('alphaSlider').value));
            if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                updateBoxOutline(parseFloat(document.getElementById('minLatSlider').value), parseFloat(document.getElementById('maxLatSlider').value), parseFloat(document.getElementById('minLonSlider').value), parseFloat(document.getElementById('maxLonSlider').value), parseFloat(document.getElementById('minDepthSlider').value), parseFloat(document.getElementById('maxDepthSlider').value), parseFloat(this.value));
            } else {
                updateDiagonal(document.getElementById('toggleDiagSliceCheckbox').checked, parseFloat(document.getElementById('diagSlider').value), parseFloat(this.value));
            }
        });
        document.getElementById('animLength').addEventListener('change', function () {
            document.getElementById('animLengthValue').textContent = this.value;
        });

        document.getElementById('data-file').addEventListener('change', updateSlidersFromDropdown);
        // Update the data-vars dropdown options when the model selected from the data-file dropdown changes
        document.getElementById('data-file').addEventListener('change', loadVarDropdown);

        // Update the box outline when the selected variable in the data-vars dropdown changes
        document.getElementById('data-vars').addEventListener('change', function() {
            const minLat = parseFloat(document.getElementById('minLatSlider').value);
            const maxLat = parseFloat(document.getElementById('maxLatSlider').value);
            const minLon = parseFloat(document.getElementById('minLonSlider').value);
            const maxLon = parseFloat(document.getElementById('maxLonSlider').value);
            const minDepth = parseFloat(document.getElementById('minDepthSlider').value);
            const maxDepth = parseFloat(document.getElementById('maxDepthSlider').value);
            const alpha = parseFloat(document.getElementById('alphaSlider').value);
            const diag = parseFloat(document.getElementById('diagSlider').value);

            if (!document.getElementById('toggleDiagSliceCheckbox').checked) {
                // Call updateBoxOutline with the current slider values
                updateBoxOutline(minLat, maxLat, minLon, maxLon, minDepth, maxDepth, alpha);
            } else {
                updateDiagonal(document.getElementById('toggleDiagSliceCheckbox').checked, diag, alpha);
            }
        });

        // Animate the slices from the min to the max slider values after the animButton button is pressed
        document.getElementById('animButton').addEventListener('click', function() {
            const minLat = parseFloat(document.getElementById('minLatSlider').value);
            const maxLat = parseFloat(document.getElementById('maxLatSlider').value);
            const minLon = parseFloat(document.getElementById('minLonSlider').value);
            const maxLon = parseFloat(document.getElementById('maxLonSlider').value);
            const minDepth = parseFloat(document.getElementById('minDepthSlider').value);
            const diag = parseFloat(document.getElementById('diagSlider').value);
            const maxDepth = parseFloat(document.getElementById('maxDepthSlider').value);
            const alpha = parseFloat(document.getElementById('alphaSlider').value);
            const animAxis = document.getElementById('anim-axis').value;
            const animTime = parseFloat(document.getElementById('animLength').value);
            const numFrames = 100;  // Set the number of slices for the animation to be 100 (all of the axes for the data sets I have created images for have fewer than 100 images in them)

            // If the animation axis is set to anything other than "none," then run the animation for the
            // selected axis
            runAnimation(minLat, maxLat, minLon, maxLon, minDepth, maxDepth, diag, alpha, animAxis, animTime, numFrames);

        });

        // Update the diagonal slice slider's value when it is moved
        document.getElementById('diagSlider').addEventListener('change', function () {
            document.getElementById('diagValue').textContent = this.value;
            if (document.getElementById('toggleDiagSliceCheckbox').checked) {
                const alpha = parseFloat(document.getElementById('alphaSlider').value);
                updateDiagonal(document.getElementById('toggleDiagSliceCheckbox').checked, parseFloat(this.value), alpha);
            }
        });
   
        // Remove the bounding box images and show the diagonal slice images instead when the diagonal slice checkbox is checked
        document.getElementById('toggleDiagSliceCheckbox').addEventListener('change', function () {
            const minLat = parseFloat(document.getElementById('minLatSlider').value);
            const maxLat = parseFloat(document.getElementById('maxLatSlider').value);
            const minLon = parseFloat(document.getElementById('minLonSlider').value);
            const maxLon = parseFloat(document.getElementById('maxLonSlider').value);
            const minDepth = parseFloat(document.getElementById('minDepthSlider').value);
            const maxDepth = parseFloat(document.getElementById('maxDepthSlider').value);
            const alpha = parseFloat(document.getElementById('alphaSlider').value);
            const diag = parseFloat(document.getElementById('diagSlider').value);

            // Remove the diagonal slice image and make the bounding box images visible again if the checkbox is unchecked
            if (!this.checked) {
                // Remove any previous diagonal slice primitive that was added to the scene from a previous call
                if (diagEntity !== null) {
                    viewer.scene.primitives.remove(diagEntity);
                }
                // Call updateBoxOutline with the current slider values
                updateBoxOutline(minLat, maxLat, minLon, maxLon, minDepth, maxDepth, alpha);
            } else {  // Remove the bounding box images and make the diagonal slice image visible when the checkbox is checked
                updateDiagonal(this.checked, diag, alpha);
            }
        });

        // Load initial dropdown and update sliders
        loadDropdown();

        var points = [];
        var distanceDisplay = document.getElementById('distanceDisplay');
        var clearButton = document.getElementById('clearButton');

        function calculateDistance(point1, point2) {
            return Cesium.Cartesian3.distance(point1, point2);
        }

        function updateDistanceDisplay(distance) {
            distanceDisplay.textContent = 'Distance: ' + distance.toFixed(2) + ' meters';
        }


        function clearDistance() {
            points = [];
            distanceDisplay.textContent = '';
            viewer.entities.removeAll();
        }

        var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        handler.setInputAction(function (click) {
            var cartesian = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);
            if (cartesian) {
                if (document.getElementById('clearCheckbox').checked) {
                    points.push(cartesian);
                }
                if (points.length >= 2) {
                    var distance = calculateDistance(points[points.length - 2], points[points.length - 1]);
                    updateDistanceDisplay(distance);
                    viewer.entities.add({
                        polyline: {
                            positions: points,
                            width: 2,
                            material: Cesium.Color.TEAL
                        }
                    });
                }
            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        document.getElementById('clearCheckbox').addEventListener('change', function () {
            if (!this.checked) {
                clearDistance();
            }
        });

        document.getElementById('toggleGlobeCheckbox').addEventListener('change', function () {
            viewer.scene.globe.show = this.checked;
        });

        document.addEventListener('DOMContentLoaded', function () {
            var toggleSubductionCheckbox = document.getElementById('toggleSubductionCheckbox');
            var subductionDataSource;

            function handleSubductionData(checked) {
                if (checked) {
                    Cesium.GeoJsonDataSource.load(auxData[0], {
                        stroke: auxColor[0],
                        strokeWidth: auxLineWidth[0],
                        fill: auxColor[0].withAlpha(auxFillOpacity[0])
                    }).then(function (dataSource) {
                        subductionDataSource = dataSource;
                        viewer.dataSources.add(dataSource);
                    }).catch(function (error) {
                        console.error('Error loading GeoJSON:', error);
                    });
                } else {
                    if (viewer.dataSources.contains(subductionDataSource)) {
                        viewer.dataSources.remove(subductionDataSource);
                    }
                }
            }

            toggleSubductionCheckbox.addEventListener('change', function () {
                handleSubductionData(this.checked);
            });

            handleSubductionData(toggleSubductionCheckbox.checked);
        });
    </script>
</body>

</html>
